

  <title> How Much Food Do I Feed My Dog \xe2\x80\x94 Dr. Gregs Dog Dish Diet</title>
  <body>
&apos;\n \n \n    Home  \n  Order Dog Dish Diet Now!  \n  Testimonials  \n  Who is Dr. Greg?  \n  Contact Dr. Greg  \n  Bonus e Book and Crock Pot Video Access With Purchase  \n  Dog Dish Diet Videos  \n  \n\t \n\n\t\t \n\n\t\t\t \n\n\t\t \n\n\t \n\t \n\t\t \n\n\t\t\t \n\t\t\t\t \n\t\t\t\t\t How Much Dry Food Should I Feed My Dog? \n\t\t\t\t\t by Dr Greg on July 24, 2011  \n\t\t\t\t \n\t\t\t\t \n \n\n \n    \n In my book, Dog Dish Diet, I go over the calories in dry and canned food and the amount of daily calories a dog should be fed. However, most people use a scoop or their hand to measure dry food. If your dog looks good\xe2\x80\xa6no need to change your methods. If your dog is on the chunky side, overweight, or grossly fat you need to measure out the food you feed them. You may also want to consider diluting\xc2\xa0 the calories in dry food with water or green beans, or feeding something with less carbohydrate calories like canned food,  home cooked food, or a piece of chicken 2-3 nights per week instead of dry food or kibble. Dog Dish Diet teaches us to feed better by learning about ingredients. Some dogs are suffering and dying because they can\xe2\x80\x99t tolerate the ingredients in some commercial foods.( chronic skin problems, ear problems , bladder infections and stones , seizures, diarrhea, diabetes, fatty tumors to name a few) \n  If your dog has skin, ear, bowel, bladder, or seizure problems consider the Dog Dish Diet and feed your pet to avoid the vet!  \n  Here is a question I received on facebook today:  \n  Doc.. about how much of the chicken stew would a 50lb dog and 80lb dog need daily if the diet was to be changed from dry to this.. of course it would be a gradual change not to upset tummies…  \n  My Answer: \n  \n    \n   My 80 lb lab eats about 12 oz twice daily. My 10 lb terrier mix eats 6 oz twice daily. My 10 pound bichon/poodle cross eats 6 oz twice daily. You can see that my small dogs need to eat more ounces per pound. In general, dogs need 10-50 calories per pound per day depending on their individual metabolism and energy level.(how much fuel they burn during their normal daily activities)Your \xc2\xa050 pound dog needs anywhere from 500-2500 calories per day depending on activity level. I usually assume 10-20 cal/pound/day for medium to large breeds, 20-30 cal/ pound /day for medium dogs, and 30-40 cal/pound /day for small active dogs. So the stew is 35 calories per ounce, and if 1000 calories needed, about 30 ounces (15 ounces twice daily). The bigger dogs often need less per pound than medium and small dogs unless they move a lot. The 80 pound would get the same or 25 ounces once daily (12 ounces twice daily). Many clients add the stew to moistened dry food as a supplement. One cup 2-3 times a week.   \n   Dry food is usually 45 calories per ounce, canned food is roughly 25 calories per ounce. An 80 pound overweight dog may only need 800 calories per day because they are a slug. This would be about 18 ounces of dry food(2 cups)(or and no hi carb treats!!   \n   Some dogs can\xe2\x80\x99t handle the carbs in dry food or kibble. They gain weight no matter how little dry food they are given. They develop lipomas or fatty tumors. They have dry, flaky, skin. They need more protein, fats, and oils in their diet. Don\xe2\x80\x99t keep feeding the same type of dry, high carbohydrate, low fat food and expect different results. Feed your pet to avoid the vet!!       \n   \t\t\t\t \n\t\t\t \n\n\t\t\t \n\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t\t Leave a Comment \n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t\t   Name *   \n\t\t\t\t\t\t   E-mail *   \n\t\t\t\t\t\t   Website  \n\t\t\t\t\t\t \n\t\t\t\t\t\t\t  \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n
  </body>


  <title> XML - Wikipedia, the free encyclopedia</title>
  <body>
\n\t\t  \n\t\t  \n\t\t\n\t\t \n\t\t\t  \n\t\t\t  \n\t\t\t\t\t\t\n\t\t\t  \n\t\t\t\n\t\t\t\t\t\t\n\t\t\t XML \n\t\t\t\n\t\t\t\n\t\t\t \n\t\t\t\t\t\t\t\t\n\t\t\t\t From Wikipedia, the free encyclopedia \n\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t  \n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t \n\t\t\t\t\tJump to: navigation ,\n\t\t\t\t\t search \n\t\t\t\t \n\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t  \n \n \n \n XML \n \n     \n \n \n  Filename extension  \n  .xml  \n \n \n  Internet media type  \n  application/xml ,   [ 1 ]    \n text/xml    [ 2 ]   (deprecated in an expired draft)   [ 3 ]    \n \n \n  Uniform Type Identifier  \n public.xml \n \n \n UTI conforms to \n public.text \n \n \n Developed by \n  World Wide Web Consortium  \n \n \n Type of format \n  Markup language  \n \n \n Extended from \n  SGML  \n \n \n Extended to \n  Numerous , including: \n XHTML , RSS , Atom , KML  \n \n \n  Standard(s)  \n  1.0 (Fifth Edition) November 26, 2008 ; 3 years ago   ( 2008-11-26 )  \n 1.1 (Second Edition) August 16, 2006 ; 5 years ago   ( 2006-08-16 )  \n \n \n  Open format ? \n Yes \n \n \n \n  Extensible Markup Language (XML)  \n \n Current Status \n Published \n \n \n Year Started \n 1996 \n \n \n Editors \n Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, Fran\xc3\xa7ois Yergeau, John Cowan \n \n \n Related Standards \n  XML Schema  \n \n \n Domain \n  Data Serialization  \n \n \n Abbreviation \n XML \n \n \n Website \n  XML 1.0  \n \n \n \n \n \n  Extensible Markup Language ( XML ) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable . It is defined in the XML 1.0 Specification   [ 4 ]   produced by the W3C , and several other related specifications, all gratis  open standards .   [ 5 ]    \n The design goals of XML emphasize simplicity, generality, and usability over the Internet .   [ 6 ]   It is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary data structures , for example in web services . \n Many application programming interfaces (APIs) have been developed for software developers to use to process XML data, and several schema systems exist to aid in the definition of XML-based languages. \n As of 2009  [update]  , hundreds of XML-based languages have been developed,   [ 7 ]   including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for many office-productivity tools, including Microsoft Office ( Office Open XML ), OpenOffice.org ( OpenDocument ), and Apple \&apos;s iWork .   [ 8 ]   XML has also been employed as the base language for communication protocols , such as XMPP . \n \n \n \n \n Contents \n \n \n   1  Key terminology   \n   2  Characters and escaping  \n \n   2.1  Valid characters   \n   2.2  Encoding detection   \n   2.3  Escaping   \n   2.4  Comments   \n   2.5  International use   \n \n \n   3  Well-formedness and error-handling   \n   4  Schemas and validation  \n \n   4.1  DTD   \n   4.2  XML Schema   \n   4.3  RELAX NG   \n   4.4  Schematron   \n   4.5  ISO DSDL and other schema languages   \n \n \n   5  Related specifications   \n   6  Use on the Internet   \n   7  Programming interfaces  \n \n   7.1  Simple API for XML (SAX)   \n   7.2  Pull parsing   \n   7.3  Document Object Model   \n   7.4  Data binding   \n   7.5  XML as data type   \n \n \n   8  History  \n \n   8.1  Sources   \n   8.2  Versions   \n \n \n   9  Criticism   \n   10  See also   \n   11  References   \n   12  Further reading   \n   13  External links   \n \n \n \n \n  [ edit ]  Key terminology  \n The material in this section is based on the XML Specification. This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use. \n \n (Unicode) Character \n By definition, an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document. \n \n \n Processor and Application \n The processor analyzes the markup and passes structured information to an application . The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an XML parser . \n \n \n Markup and Content \n The characters which make up an XML document are divided into markup and content . Markup and content may be distinguished by the application of simple syntactic rules. All strings which constitute markup either begin with the character &quot;&lt;&quot; and end with a &quot;&gt;&quot;, or begin with the character &quot;&amp;&quot; and end with a &quot;;&quot;. Strings of characters which are not markup are content. \n \n \n Tag \n A markup construct that begins with &quot;&lt;&quot; and ends with &quot;&gt;&quot;. Tags come in three flavors: start-tags , for example &lt;section&gt; , end-tags , for example &lt;/section&gt; , and empty-element tags , for example &lt;line-break /&gt; . \n \n \n Element \n A logical document component either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start- and end-tags, if any, are the element\&apos;s content , and may contain markup, including other elements, which are called child elements . An example of an element is &lt;Greeting&gt;Hello, world.&lt;/Greeting&gt; (see hello world ). Another is &lt;line-break /&gt; . \n \n \n Attribute \n A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag. In the example (below) the element img has two attributes, src and alt : &lt;img src=&quot;madonna.jpg&quot; alt=\&apos;Foligno Madonna, by Raphael\&apos; /&gt; . Another example would be &lt;step number=&quot;3&quot;&gt;Connect A to B.&lt;/step&gt; where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;. \n \n \n XML Declaration \n XML documents may begin by declaring some information about themselves, as in the following example. \n \n \n \n \n  &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;  \n  \n \n  [ edit ]  Characters and escaping  \n XML documents consist entirely of characters from the Unicode repertoire. Except for a small number of specifically excluded control characters , any character defined by Unicode may appear within the content of an XML document. The selection of characters that may appear within markup is somewhat more limited but still large. \n XML includes facilities for identifying the encoding of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly. \n  [ edit ]  Valid characters  \n Main article: Valid characters in XML  \n Unicode code points in the following ranges are valid in XML 1.0 documents:   [ 9 ]    \n \n U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0; \n U+0020\xe2\x80\x93U+D7FF, U+E000\xe2\x80\x93U+FFFD: this excludes some (not all) non-characters in the BMP (all surrogates, U+FFFE and U+FFFF are forbidden); \n U+10000\xe2\x80\x93U+10FFFF: this includes all code points in supplementary planes, including non-characters. \n \n XML 1.1   [ 10 ]   extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001\xe2\x80\x93U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as&amp;#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected. \n The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document. \n  [ edit ]  Encoding detection  \n The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;. Unicode itself defines encodings that cover the entire repertoire; well-known ones include UTF-8 and UTF-16 .   [ 11 ]   There are many other text encodings that pre-date Unicode, such as ASCII and ISO/IEC 8859 ; their character repertoires in almost every case are subsets of the Unicode character set. \n XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.   [ 12 ]   Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser. \n  [ edit ]  Escaping  \n XML provides  escape  facilities for including characters which are problematic to include directly. For example: \n \n The characters &quot;&lt;&quot; and &quot;&amp;&quot; are key syntax markers and may never appear in content outside of a CDATA section.   [ 13 ]    \n Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;\xc3\xa9&quot;. \n It might not be possible to type the character on the author\&apos;s machine. \n Some characters have glyphs that cannot be visually distinguished from other characters: examples are\n \n non-breaking-space ( &amp;#xa0; ) &quot; &quot;\n \n compare space ( &amp;#x20; ) &quot; &quot; \n \n \n Cyrillic Capital Letter A ( &amp;#x410; ) &quot;\xd0\x90&quot;\n \n compare Latin Capital Letter A ( &amp;#x61; ) &quot;A&quot; \n \n \n \n \n \n There are five predefined entities : \n \n  &amp;lt; represents &quot;&lt;&quot; \n  &amp;gt; represents &quot;&gt;&quot; \n  &amp;amp; represents &quot;&amp;&quot; \n  &amp;apos; represents \&apos; \n  &amp;quot; represents &quot; \n \n All permitted Unicode characters may be represented with a  numeric character reference  . Consider the Chinese character &quot;\xe4\xb8\xad&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013. A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as &amp;#20013; or &amp;#x4e2d; . Similarly, the string &quot; I&lt;3 J\xc3\xb6rg &quot; could be encoded for inclusion in an XML document as &quot; I&amp;lt;3 J&amp;#xF6;rg &quot;. \n &quot; &amp;#0; &quot; is not permitted, however, because the null character is one of the control characters excluded from XML, even when using a numeric character reference.   [ 14 ]   An alternative encoding mechanism such as Base64 is needed to represent such characters. \n  [ edit ]  Comments  \n Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot; -- &quot; (double-hyphen) is not allowed inside comments. Comments start with &quot;&lt;!--&quot;. The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding. \n An example of a valid comment: &quot; &lt;!-- no need to escape&lt;code&gt;&amp;such in comments --&gt; &quot; \n  [ edit ]  International use  \n \n \n   \n  This example contains Chinese text. Without proper rendering support , you may see question marks, boxes, or other symbols instead of Chinese characters . \n \n \n \n \n   \n  This example contains Cyrillic text . Without proper rendering support , you may see question marks or boxes , misplaced vowels or missing conjuncts instead of Cyrillic letters. \n \n \n XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&lt;&quot;). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters: \n \n \n \n  &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;  \n &lt;\xe4\xbf\x84\xe8\xaf\xad &gt;  \xd0\xb4\xd0\xb0\xd0\xbd\xd0\xbd\xd1\x8b\xd0\xb5 &lt;/\xe4\xbf\x84\xe8\xaf\xad &gt;  \n  \n \n  [ edit ]  Well-formedness and error-handling  \n Main article: Well-formed document  \n The XML specification defines an XML document as a text that is well-formed , i.e. it satisfies a list of syntax rules provided in the specification. The list is fairly lengthy; some key points are: \n \n It contains only properly encoded legal Unicode characters. \n None of the special syntax characters such as &quot;&lt;&quot; and &quot;&amp;&quot; appear except when performing their markup-delineation roles. \n The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping. \n The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters !&quot;#$%&amp;\&apos;()*+,/;&lt;=&gt;?@[\\]^`{|}~, nor a space character, and cannot start with -, ., or a numeric digit. \n There is a single &quot;root&quot; element that contains all the other elements. \n \n The definition of an XML document excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as draconian , stands in notable contrast to the behavior of programs that process HTML , which are designed to produce a reasonable result even in the presence of severe markup errors.   [ 15 ]   XML\&apos;s policy in this area has been criticized as a violation of Postel\&apos;s law (&quot;Be conservative in what you send; be liberal in what you accept&quot;).   [ 16 ]    \n  [ edit ]  Schemas and validation  \n In addition to being well-formed, an XML document may be valid . This means that it contains a reference to a Document Type Definition (DTD) , and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies. \n XML processors are classified as validating or non-validating depending on whether or not they check XML documents for validity. A processor that discovers a validity error must be able to report it, but may continue normal processing. \n A DTD is an example of a  schema  or grammar . Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships. \n  [ edit ]  DTD  \n Main article: Document Type Definition  \n The oldest schema language for XML is the Document Type Definition (DTD), inherited from SGML . \n DTDs have the following benefits: \n \n DTD support is ubiquitous due to its inclusion in the XML 1.0 standard. \n DTDs are terse compared to element-based schema languages and consequently present more information in a single screen. \n DTDs allow the declaration of standard public entity sets for publishing characters. \n DTDs define a document type rather than the types used by a namespace, thus grouping all constraints for a document in a single collection. \n \n DTDs have the following limitations: \n \n They have no explicit support for newer features of XML, most importantly namespaces . \n They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes. \n They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual macros ), which make it easier to define complex grammars, but at the expense of clarity. \n They use a syntax based on regular expression syntax, inherited from SGML , to describe the schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be. \n \n Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining entities , which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes. \n DTD technology is still used in many applications because of its ubiquity. \n  [ edit ]  XML Schema  \n Main article: XML Schema (W3C)  \n A newer schema language, described by the W3C as the successor of DTDs, is XML Schema , often referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system and allow for more detailed constraints on an XML document\&apos;s logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them. \n  [ edit ]  RELAX NG  \n Main article: RELAX NG  \n  RELAX NG was initially specified by OASIS and is now also an ISO/IEC International Standard (as part of DSDL ). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are isomorphic and James Clark \&apos;s Trang conversion tool can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins ; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes. \n  [ edit ]  Schematron  \n Main article: Schematron  \n  Schematron is a language for making assertions about the presence or absence of patterns in an XML document. It typically uses XPath expressions. \n  [ edit ]  ISO DSDL and other schema languages  \n The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing . \n Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the infoset augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these. \n  [ edit ]  Related specifications  \n A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0. It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core. \n \n  XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces. \n  XML Base defines the xml:base attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element. \n The XML Information Set or XML infoset describes an abstract data model for XML documents in terms of information items . The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow. \n xml:id Version 1.0 asserts that an attribute named xml:id functions as an &quot;ID attribute&quot; in the sense used in a DTD. \n  XPath defines a syntax named XPath expressions which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document. XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data. \n  XSLT is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes. \n  XSL Formatting Objects , or XSL-FO, is a markup language for XML document formatting which is most often used to generate PDFs . \n  XQuery is an XML-oriented query language strongly rooted in XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for XML databases . \n  XML Signature defines syntax and processing rules for creating digital signatures on XML content. \n  XML Encryption defines syntax and processing rules for encrypting XML content. \n \n Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including XInclude , XLink , and XPointer . \n  [ edit ]  Use on the Internet  \n XML has come into common use for the interchange of data over the Internet. RFC 3023 gives rules for the construction of Internet Media Types for use when sending XML. It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data are in XML, and nothing about its semantics . The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.   [ 3 ]    RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for SVG . \n Further guidelines for the use of XML in a networked context may be found in RFC 3470 , also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language. \n XML can also form a crucial part of a databaseless design . \n  [ edit ]  Programming interfaces  \n The design goals of XML include, &quot;It shall be easy to write programs which process XML documents.&quot;   [ 6 ]   Despite this, the XML specification contains almost no information about how programmers might go about doing such processing. The XML Infoset specification provides a vocabulary to refer to the constructs within an XML document, but also does not provide any guidance on how to access this information. A variety of APIs for accessing XML have been developed and used, and some have been standardized. \n Existing APIs for XML processing tend to fall into these categories: \n \n Stream-oriented APIs accessible from a programming language, for example SAX and StAX . \n Tree-traversal APIs accessible from a programming language, for example DOM . \n  XML data binding , which provides an automated translation between an XML document and programming-language objects. \n Declarative transformation languages such as XSLT and XQuery . \n \n Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives. Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions. \n XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large XML databases . \n  [ edit ]  Simple API for XML (SAX)  \n  SAX is a lexical , event-driven interface in which a document is read serially and its contents are reported as callbacks to various methods on a handler object of the user\&apos;s design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document. \n  [ edit ]  Pull parsing  \n Pull parsing   [ 17 ]   treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLReader in PHP and System.Xml.XmlReader in the .NET Framework . \n A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace , values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code.. \n  [ edit ]  Document Object Model  \n The Document Object Model (DOM) is an interface -oriented application programming interface that allows for navigation of the entire document as if it were a tree of node  objects representing the document\&apos;s contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings . DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed. \n  [ edit ]  Data binding  \n Another form of XML processing API is XML data binding , where XML data are made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB) and XML Serialization in .NET.   [ 18 ]    \n  [ edit ]  XML as data type  \n XML is beginning to appear as a first-class data type in other languages. The ECMAScript for XML (E4X) extension to the ECMAScript /JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.   [ 19 ]   E4X is supported by the Mozilla 2.5+ browsers and Adobe Actionscript , but has not been adopted more universally. Similar notations are used in Microsoft\&apos;s LINQ implementation for Microsoft .NET 3.5 and above, and in Scala (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the&lt;[ ]&gt;notation.   [ 20 ]   The Resource Description Framework defines a data type rdf:XMLLiteral to hold wrapped, canonical XML .   [ 21 ]    \n  [ edit ]  History  \n XML is an application profile of SGML (ISO 8879).   [ 22 ]    \n The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.   [ 23 ]      [ 24 ]   By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web , and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C\&apos;s activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.   [ 25 ]    \n XML was compiled by a working group of eleven members,   [ 26 ]   supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.   [ 27 ]    James Clark served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty /&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen . Halfway through the project Bray accepted a consulting engagement with Netscape , provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft\&apos;s Jean Paoli as a third co-editor. \n The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in a short burst of intense work between August and November 1996   [ 28 ]   , when the first Working Draft of an XML specification was published.   [ 29 ]   Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998. \n  [ edit ]  Sources  \n  XML is a profile of an ISO standard SGML , and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ( processing instructions ), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set ). \n Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and HTML , in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP ) metadata accompanied the resource rather than being needed at the declaration of a link. The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0\&apos;s naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime . \n Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;   [ 30 ]   the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System. \n  [ edit ]  Versions  \n There are two current versions of XML. The first ( XML 1.0 ) was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use. \n The second ( XML 1.1 ) was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,   [ 31 ]   and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.   [ 32 ]   The main changes are to enable the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.   [ 33 ]    \n Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the Unicode standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces redundancy . The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the Balinese , Cham , or Phoenician scripts among many others which have been added to Unicode since Unicode 3.2.   [ 32 ]    \n Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references   [ 34 ]   ). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly. \n There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for skunkworks ), written by one of the original developers of XML,   [ 35 ]   contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces , XML Base and XML Information Set ( infoset ) into the base standard. \n The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name  Fast Infoset  for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1). \n  [ edit ]  Criticism  \n XML and its extensions have regularly been criticized for verbosity and complexity.   [ 36 ]   Mapping the basic tree model of XML to type systems of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a self-describing language   [ 37 ]   (though the XML specification itself makes no such claim). JSON and YAML are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents. \n  [ edit ]  See also  \n \n  List of XML markup languages  \n  Comparison of layout engines (XML)  \n  Binary XML  \n  EBML  \n  WBXML  \n  Struxt C-style equivalent to XML \n  Category:XML  \n  Category:XML-based standards  \n  Billion laughs (a denial-of-service attack on XML parsers) \n  XML Protocol  \n  Comparison of data serialization formats  \n \n  [ edit ]  References  \n \n \n   ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 9\xe2\x80\x9311 . http://tools.ietf.org/html/rfc3023#section-3.2   . Retrieved 2010-01-04 .       \n   ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 7\xe2\x80\x939 . http://tools.ietf.org/html/rfc3023#section-3.1   . Retrieved 2010-01-04 .       \n ^    a        b     M. Murata, D. Kohn, and C. Lilley (2009-09-24). &quot;Internet Drafts: XML Media Types&quot; . IETF . http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03   . Retrieved 2010-06-10 .       \n   ^    &quot;XML 1.0 Specification&quot; . W3.org . http://www.w3.org/TR/REC-xml   . Retrieved 2010-08-22 .       \n   ^    &quot;W3C DOCUMENT LICENSE&quot;  . http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231  .       \n ^    a        b      &quot;XML 1.0 Origin and Goals&quot;  . http://www.w3.org/TR/REC-xml/#sec-origin-goals   . Retrieved July 2009 .       \n   ^    &quot;XML Applications and Initiatives&quot;  . http://xml.coverpages.org/xmlApplications.html  .       \n   ^    &quot;Introduction to iWork Programming Guide. Mac OS X Reference Library&quot; . Apple . http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html  .       \n   ^    &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot; . W3.org . http://www.w3.org/TR/2006/REC-xml-20060816/#charsets   . Retrieved 2010-08-22 .       \n   ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#charsets   . Retrieved 2010-08-22 .       \n   ^    &quot;Characters vs. Bytes&quot;  . http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF  .       \n   ^    &quot;Autodetection of Character Encodings&quot;  . http://www.w3.org/TR/REC-xml/#sec-guessing  .       \n   ^  It is allowed, but not recommended, to use &quot;&lt;&quot; in XML entity values: Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition  \n   ^    &quot;W3C I18N FAQ: HTML, XHTML, XML and Control Codes&quot;  . http://www.w3.org/International/questions/qa-controls  .       \n   ^   http://web.archive.org/web/20110726002036/http://diveintomark.org/archives/2004/01/16/draconianism  \n   ^   http://web.archive.org/web/20110514120305/http://diveintomark.org/archives/2004/01/08/postels-law  \n   ^   Push, Pull, Next! by Bob DuCharme, at XML.com \n   ^    &quot;XML Serialization in the .NET Framework&quot; . Msdn.microsoft.com . http://msdn.microsoft.com/en-us/library/ms950721.aspx   . Retrieved 2009-07-31 .       \n   ^    &quot;Processing XML with E4X&quot; . Mozilla Developer Center . Mozilla Foundation . https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x  .       \n   ^    &quot;XML Shell: Core Syntax&quot; . xmlsh. 2010-05-13 . http://www.xmlsh.org/CoreSyntax   . Retrieved 2010-08-22 .       \n   ^    &quot;Resource Description Framework (RDF): Concepts and Abstract Syntax&quot; . W3.org . http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral   . Retrieved 2010-08-22 .       \n   ^    ISO/IEC 19757-3 . ISO / IEC . 1 June 2006. p. vi       \n   ^   Bray, Tim (February 2005). &quot;A conversation with Tim Bray: Searching for ways to tame the world\&apos;s vast stores of information&quot; . Association for Computing Machinery\&apos;s &quot;Queue site&quot; . http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282   . Retrieved April 16, 2006 .       \n   ^   edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley. (1988). &quot;Publishers, multimedia, and interactivity&quot;. Interactive multimedia . Cobb Group. ISBN   1-55615-124-1 .       \n   ^   Eliot Kimber (2006). &quot;XML is 10&quot;  . http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html  .       \n   ^  The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210 . \n   ^    &quot;Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG&quot; . W3.org . http://www.w3.org/XML/9712-reports.html   . Retrieved 2009-07-31 .       \n   ^  Jon Bosak: The Birth of XML  \n   ^    &quot;Extensible Markup Language (XML)&quot; . W3.org. 1996-11-14 . http://www.w3.org/TR/WD-xml-961114.html   . Retrieved 2009-07-31 .       \n   ^   Jon Bosak, Sun Microsystems (2006-12-07). &quot;Closing Keynote, XML 2006&quot; . 2006.xmlconference.org . http://2006.xmlconference.org/proceedings/162/presentation.html   . Retrieved 2009-07-31 .       \n   ^    &quot;Extensible Markup Language (XML) 1.0 (Third Edition)&quot; . W3.org . http://www.w3.org/TR/2004/REC-xml-20040204   . Retrieved 2010-08-22 .       \n ^    a        b      &quot;Extensible Markup Language (XML) 1.1 (Second Edition) \xe2\x80\x93 Rationale and list of changes for XML 1.1&quot; . W3C . http://www.w3.org/TR/xml11/#dt-name   . Retrieved 2009-12-11 .       \n   ^   Harold, Elliotte Rusty (2004).  Effective XML  . Addison-Wesley. pp. 10\xe2\x80\x9319. ISBN   0321150406  . http://www.cafeconleche.org/books/effectivexml/  .       \n   ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2010-08-22 .       \n   ^  Tim Bray:  Extensible Markup Language - SW (XML-SW) . 2002-02-10 \n   ^  Jeff Atwood (2009): XML: The Angle Bracket Tax  \n   ^  Eric Brown (2003): The Myth of Self-Describing XML  \n \n \n  [ edit ]  Further reading  \n \n Annex A of ISO 8879:1986 (SGML) \n  Lawrence A. Cunningham (2005). &quot;Language, Deals and Standards: The Future of XML Contracts&quot;. Washington University Law Review . SSRN   900616 .       \n  Bosak, Jon; Tim Bray (May 1999). &quot;XML and the Second-Generation Web&quot;. Scientific American .      Online at XML and the Second-Generation Web . \n   Kelly, Sean (February 6, 2006). &quot;Making Mistakes with XML&quot; . Developer.com  . http://www.developer.com/xml/article.php/10929_3583081_1   . Retrieved 2010-10-26 .       \n  Ogbuji, Uche (14 Nov 2006). &quot;Thinking XML: The XML decade&quot; . developerWorks . IBM  . http://www-128.ibm.com/developerworks/library/x-think38.html   . Retrieved 2010-10-26 .       \n  St. Laurent, Simon (February 12, 2003). &quot;Five years later, XML..&quot; . O\&apos;Reilly XML Blog . O\&apos;Reilly Media  . http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html   . Retrieved 2010-10-26 .       \n   &quot;W3C XML is Ten!&quot; . World Wide Web Consortium . 12 February 2008 . http://www.w3.org/2008/02/xml10-pressrelease   . Retrieved 2010-10-26 .       \n  Flynn, Peter [ed] (5 January 2011). &quot;The XML FAQ&quot; . Cork: Silmaril . http://xml.silmaril.ie/  .       \n \n  [ edit ]  External links  \n \n \n   \n Wikimedia Commons has media related to:   XML    \n \n \n \n \n   \n Wikibooks has more on the topic of\n    XML    \n \n \n \n \n \n \n   \n \n This article\&apos;s use of external links may not follow Wikipedia\&apos;s policies or guidelines . Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references   (November 2010)   \n \n \n \n  W3C XML homepage  \n  XML 1.0 Specification  \n  Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe  \n  XML, Java and the Future of the Web by Jon Bosak  \n  XML.gov  \n  XML: Ten year anniversary by Elliot Kimber \n  23 XML fallacies to watch out for by Sean McGrath \n  XML Injection - Web Application Security Consortium \n \n   \n \n \n \n \n \n \n \n \n   v   \n   d   \n   e   \n \n \n  World Wide Web Consortium  \n \n \n \n  \n \n \n Products and \nstandards \n \n  \n \n \n \n  Recommendations  \n \n \n \n \n  Canonical XML  \n  CDF  \n  CSS  \n  DOM  \n  Geolocation API  \n  HTML  \n  ITS  \n  MathML  \n  OWL  \n  P3P  \n  PLS  \n  RDF  \n  RDF Schema  \n  SISR  \n  SKOS  \n  SMIL  \n  SOAP  \n  SRGS  \n  SSML  \n  SVG  \n  SPARQL  \n  Timed Text  \n  VoiceXML  \n  WSDL  \n  XForms  \n  XHTML  \n  XHTML+RDFa  \n  XInclude  \n  XLink  \n  XML  \n  XML Base  \n  XML Encryption  \n  XML Events  \n  XML Information Set  \n  XML namespace  \n  XML Schema  \n  XML Signature  \n  XPath  1.0 , 2.0  \n  XPointer  \n  XProc  \n  XQuery  \n  XSL  \n  XSL-FO  \n  XSLT  ( elements )  \n \n \n \n \n \n  \n \n \n \n Notes \n \n \n \n \n  XAdES  \n  XHTML+SMIL  \n  XUP  \n \n \n \n \n \n  \n \n \n \n Working Drafts \n \n \n \n \n  CCXML  \n  CURIE  \n  HTML5  \n  InkML  \n  RIF  \n  SCXML  \n  SMIL Timesheets  \n  sXBL  \n  WICD  \n  XFDL  \n  XFrames  \n  XBL  \n  XHTML+MathML+SVG  \n  XMLHttpRequest  \n \n \n \n \n \n  \n \n \n \n Guidelines \n \n \n \n \n  Web Content Accessibility Guidelines  \n \n \n \n \n \n  \n \n \n \n Initiative \n \n \n \n \n  Multimodal Interaction Activity  \n  Markup Validation Service  \n  Web Accessibility Initiative  \n \n \n \n \n \n  \n \n \n \n Deprecated \n \n \n \n \n  C-HTML  \n  HDML  \n  JSSS  \n  PGML  \n  VML  \n \n \n \n \n \n \n \n \n  \n \n \n Organizations \n \n \n \n  World Wide Web Foundation  \n  SVG Working Group  \n  WebOnt  \n  W3C Device Description Working Group  \n  WHATWG  \n \n \n \n \n \n  \n \n \n Software \n \n \n \n  Agora  \n  Argo  \n  Arena  \n  Amaya  \n  CERN httpd  \n  Libwww  \n  Line Mode Browser  \n \n \n \n \n \n  \n \n \n Conference-related \n \n \n \n  IW3C2  \n  World Wide Web Conference  \n  WWW1  \n \n \n \n \n \n \n \n \n\n\n\n\n\n \t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t \n\t\t\t\tRetrieved from &quot; http://en.wikipedia.org/w/index.php?title=XML&amp;oldid=471695129 &quot;\t\t\t\t \n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t
  </body>


  <title> How Much Food Do I Feed My Dog — Dr. Gregs Dog Dish Diet</title>
  <body>
&apos;      Home    Order Dog Dish Diet Now!    Testimonials    Who is Dr. Greg?    Contact Dr. Greg    PDF Introduction to Crock Pot Cooking Access With Purchase    Dog Dish Diet Videos              How Much Dry Food Should I Feed My Dog?  by Dr Greg on July 24, 2011           In my book, Dog Dish Diet, I go over the calories in dry and canned food and the amount of daily calories a dog should be fed. However, most people use a scoop or their hand to measure dry food. If your dog looks good…no need to change your methods. If your dog is on the chunky side, overweight, or grossly fat you need to measure out the food you feed them. You may also want to consider diluting  the calories in dry food with water or green beans, or feeding something with less carbohydrate calories like canned food,  home cooked food, or a piece of chicken 2-3 nights per week instead of dry food or kibble. Dog Dish Diet teaches us to feed better by learning about ingredients. Some dogs are suffering and dying because they can’t tolerate the ingredients in some commercial foods.( chronic skin problems, ear problems , bladder infections and stones , seizures, diarrhea, diabetes, fatty tumors to name a few)   If your dog has skin, ear, bowel, bladder, or seizure problems consider the Dog Dish Diet and feed your pet to avoid the vet!    Here is a question I received on facebook today:    Doc.. about how much of the chicken stew would a 50lb dog and 80lb dog need daily if the diet was to be changed from dry to this.. of course it would be a gradual change not to upset tummies…    My Answer:          My 80 lb lab eats about 12 oz twice daily. My 10 lb terrier mix eats 6 oz twice daily. My 10 pound bichon/poodle cross eats 6 oz twice daily. You can see that my small dogs need to eat more ounces per pound. In general, dogs need 10-50 calories per pound per day depending on their individual metabolism and energy level.(how much fuel they burn during their normal daily activities)Your  50 pound dog needs anywhere from 500-2500 calories per day depending on activity level. I usually assume 10-20 cal/pound/day for medium to large breeds, 20-30 cal/ pound /day for medium dogs, and 30-40 cal/pound /day for small active dogs. So the stew is 35 calories per ounce, and if 1000 calories needed, about 30 ounces (15 ounces twice daily). The bigger dogs often need less per pound than medium and small dogs unless they move a lot. The 80 pound would get the same or 25 ounces once daily (12 ounces twice daily). Many clients add the stew to moistened dry food as a supplement. One cup 2-3 times a week.      Dry food is usually 45 calories per ounce, canned food is roughly 25 calories per ounce. An 80 pound overweight dog may only need 800 calories per day because they are a slug. This would be about 18 ounces of dry food(2 cups)(or and no hi carb treats!!      Some dogs can’t handle the carbs in dry food or kibble. They gain weight no matter how little dry food they are given. They develop lipomas or fatty tumors. They have dry, flaky, skin. They need more protein, fats, and oils in their diet. Don’t keep feeding the same type of dry, high carbohydrate, low fat food and expect different results. Feed your pet to avoid the vet!!                Leave a Comment      Name *      E-mail *      Website                   Previous post: Temporary Home Remedies for Ear Infections   Next post: Why Does My Dog Eat Poop?                Find more at MindBites, the how-to video marketplace !      Always be among the first to know      Want more articles like the ones to the left?
For your convenience, I’ll send my latest posts directly to your inbox. Sign up now…it’s simple.                    Name:       Email:                             Order your special autographed copy now!           Archives    January 2012    December 2011    November 2011    October 2011    September 2011    August 2011    July 2011    June 2011    May 2011    April 2011    March 2011    February 2011    January 2011    December 2010    November 2010    October 2010    September 2010    August 2010    July 2010    June 2010    May 2010    April 2010    March 2010    February 2010    January 2010    December 2009    November 2009    October 2009    September 2009    August 2009    July 2009    June 2009             Receive your  FREE Copy of Dr. Greg&apos;s 11 Practical Home Remedies for Your Dog              Name  &amp;nbsp;     Email  &amp;nbsp;                  Dog Dish Diet Wins Gold Medal, 2010 Living Now Book Award         Dog Dish Diet Honored with a 2010 Indie Excellence Award         Dog Dish Diet Receives 2010 Next Generation Book Award, Finalist         Dog Dish Diet Wins 2010 San Francisco Book Festival, Honorable Mention                         Tags   California  california veterinarian  canine flu  canine health  canine nutrition  canine vaccines  canine viruses  cat food  cat health  cats  changing do habits  dog bones  Dog Dish Diet  dog food  dog food allergies  dog health  dog nutrition  dog tumors  Dr. Greg  Dr. Greg&apos;s Dog Dish Diet  ear problems in dogs  funny animal story  Gilroy  Gilroy Today  glucosamine  Greg Martinez DVM  healthy dog food  healthy dog snack  healthy eating for cats  healthy eating for dogs  joint pain  neutraceuticals  Omega 3  OPC  overweight cats  parrot  parvo  people food for dogs  pets  pet safety  poisons  radio broadcast  tick-borne diseases  ticks  veterinarian           Dog Dish Diet on Facebook          © 2011 Greg Martinez, DVM   WordPress Admin         
  </body>


  <title> XML - Wikipedia, the free encyclopedia</title>
  <body>
            XML   From Wikipedia, the free encyclopedia    Jump to: navigation , search        XML           Filename extension    .xml      Internet media type    application/xml ,   [ 1 ]     text/xml    [ 2 ]   (deprecated in an expired draft)   [ 3 ]        Uniform Type Identifier   public.xml    UTI conforms to  public.text    Developed by   World Wide Web Consortium     Type of format   Markup language     Extended from   SGML     Extended to   Numerous , including:  XHTML , RSS , Atom , KML      Standard(s)    1.0 (Fifth Edition) November 26, 2008 ; 3 years ago   ( 2008-11-26 )   1.1 (Second Edition) August 16, 2006 ; 5 years ago   ( 2006-08-16 )      Open format ?  Yes      Extensible Markup Language (XML)    Current Status  Published    Year Started  1996    Editors  Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan    Related Standards   XML Schema     Domain   Data Serialization     Abbreviation  XML    Website   XML 1.0         Extensible Markup Language ( XML ) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable . It is defined in the XML 1.0 Specification   [ 4 ]   produced by the W3C , and several other related specifications, all gratis  open standards .   [ 5 ]     The design goals of XML emphasize simplicity, generality, and usability over the Internet .   [ 6 ]   It is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary data structures , for example in web services .  Many application programming interfaces (APIs) have been developed for software developers to use to process XML data, and several schema systems exist to aid in the definition of XML-based languages.  As of 2009  [update]  , hundreds of XML-based languages have been developed,   [ 7 ]   including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for many office-productivity tools, including Microsoft Office ( Office Open XML ), OpenOffice.org ( OpenDocument ), and Apple &apos;s iWork .   [ 8 ]   XML has also been employed as the base language for communication protocols , such as XMPP .      Contents      1  Key terminology      2  Characters and escaping      2.1  Valid characters      2.2  Encoding detection      2.3  Escaping      2.4  Comments      2.5  International use        3  Well-formedness and error-handling      4  Schemas and validation      4.1  DTD      4.2  XML Schema      4.3  RELAX NG      4.4  Schematron      4.5  ISO DSDL and other schema languages        5  Related specifications      6  Use on the Internet      7  Programming interfaces      7.1  Simple API for XML (SAX)      7.2  Pull parsing      7.3  Document Object Model      7.4  Data binding      7.5  XML as data type        8  History      8.1  Sources      8.2  Versions        9  Criticism      10  See also      11  References      12  Further reading      13  External links         [ edit ]  Key terminology   The material in this section is based on the XML Specification. This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use.   (Unicode) Character  By definition, an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document.    Processor and Application  The processor analyzes the markup and passes structured information to an application . The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an XML parser .    Markup and Content  The characters which make up an XML document are divided into markup and content . Markup and content may be distinguished by the application of simple syntactic rules. All strings which constitute markup either begin with the character &quot;&lt;&quot; and end with a &quot;&gt;&quot;, or begin with the character &quot;&amp;&quot; and end with a &quot;;&quot;. Strings of characters which are not markup are content.    Tag  A markup construct that begins with &quot;&lt;&quot; and ends with &quot;&gt;&quot;. Tags come in three flavors: start-tags , for example &lt;section&gt; , end-tags , for example &lt;/section&gt; , and empty-element tags , for example &lt;line-break /&gt; .    Element  A logical document component either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start- and end-tags, if any, are the element&apos;s content , and may contain markup, including other elements, which are called child elements . An example of an element is &lt;Greeting&gt;Hello, world.&lt;/Greeting&gt; (see hello world ). Another is &lt;line-break /&gt; .    Attribute  A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag. In the example (below) the element img has two attributes, src and alt : &lt;img src=&quot;madonna.jpg&quot; alt=&apos;Foligno Madonna, by Raphael&apos; /&gt; . Another example would be &lt;step number=&quot;3&quot;&gt;Connect A to B.&lt;/step&gt; where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;.    XML Declaration  XML documents may begin by declaring some information about themselves, as in the following example.       &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;       [ edit ]  Characters and escaping   XML documents consist entirely of characters from the Unicode repertoire. Except for a small number of specifically excluded control characters , any character defined by Unicode may appear within the content of an XML document. The selection of characters that may appear within markup is somewhat more limited but still large.  XML includes facilities for identifying the encoding of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly.   [ edit ]  Valid characters   Main article: Valid characters in XML   Unicode code points in the following ranges are valid in XML 1.0 documents:   [ 9 ]      U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0;  U+0020–U+D7FF, U+E000–U+FFFD: this excludes some (not all) non-characters in the BMP (all surrogates, U+FFFE and U+FFFF are forbidden);  U+10000–U+10FFFF: this includes all code points in supplementary planes, including non-characters.   XML 1.1   [ 10 ]   extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001–U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as&amp;#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected.  The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document.   [ edit ]  Encoding detection   The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;. Unicode itself defines encodings that cover the entire repertoire; well-known ones include UTF-8 and UTF-16 .   [ 11 ]   There are many other text encodings that pre-date Unicode, such as ASCII and ISO/IEC 8859 ; their character repertoires in almost every case are subsets of the Unicode character set.  XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.   [ 12 ]   Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser.   [ edit ]  Escaping   XML provides  escape  facilities for including characters which are problematic to include directly. For example:   The characters &quot;&lt;&quot; and &quot;&amp;&quot; are key syntax markers and may never appear in content outside of a CDATA section.   [ 13 ]     Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;é&quot;.  It might not be possible to type the character on the author&apos;s machine.  Some characters have glyphs that cannot be visually distinguished from other characters: examples are  non-breaking-space ( &amp;#xa0; ) &quot; &quot;  compare space ( &amp;#x20; ) &quot; &quot;    Cyrillic Capital Letter A ( &amp;#x410; ) &quot;А&quot;  compare Latin Capital Letter A ( &amp;#x61; ) &quot;A&quot;       There are five predefined entities :    &amp;lt; represents &quot;&lt;&quot;   &amp;gt; represents &quot;&gt;&quot;   &amp;amp; represents &quot;&amp;&quot;   &amp;apos; represents &apos;   &amp;quot; represents &quot;   All permitted Unicode characters may be represented with a  numeric character reference  . Consider the Chinese character &quot;中&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013. A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as &amp;#20013; or &amp;#x4e2d; . Similarly, the string &quot; I&lt;3 Jörg &quot; could be encoded for inclusion in an XML document as &quot; I&amp;lt;3 J&amp;#xF6;rg &quot;.  &quot; &amp;#0; &quot; is not permitted, however, because the null character is one of the control characters excluded from XML, even when using a numeric character reference.   [ 14 ]   An alternative encoding mechanism such as Base64 is needed to represent such characters.   [ edit ]  Comments   Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot; -- &quot; (double-hyphen) is not allowed inside comments. Comments start with &quot;&lt;!--&quot;. The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding.  An example of a valid comment: &quot; &lt;!-- no need to escape&lt;code&gt;&amp;such in comments --&gt; &quot;   [ edit ]  International use         This example contains Chinese text. Without proper rendering support , you may see question marks, boxes, or other symbols instead of Chinese characters .          This example contains Cyrillic text . Without proper rendering support , you may see question marks or boxes , misplaced vowels or missing conjuncts instead of Cyrillic letters.    XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&lt;&quot;). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters:      &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;   &lt;俄语 &gt;  данные &lt;/俄语 &gt;       [ edit ]  Well-formedness and error-handling   Main article: Well-formed document   The XML specification defines an XML document as a text that is well-formed , i.e. it satisfies a list of syntax rules provided in the specification. The list is fairly lengthy; some key points are:   It contains only properly encoded legal Unicode characters.  None of the special syntax characters such as &quot;&lt;&quot; and &quot;&amp;&quot; appear except when performing their markup-delineation roles.  The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping.  The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters !&quot;#$%&amp;&apos;()*+,/;&lt;=&gt;?@[\]^`{|}~, nor a space character, and cannot start with -, ., or a numeric digit.  There is a single &quot;root&quot; element that contains all the other elements.   The definition of an XML document excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as draconian , stands in notable contrast to the behavior of programs that process HTML , which are designed to produce a reasonable result even in the presence of severe markup errors.   [ 15 ]   XML&apos;s policy in this area has been criticized as a violation of Postel&apos;s law (&quot;Be conservative in what you send; be liberal in what you accept&quot;).   [ 16 ]      [ edit ]  Schemas and validation   In addition to being well-formed, an XML document may be valid . This means that it contains a reference to a Document Type Definition (DTD) , and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies.  XML processors are classified as validating or non-validating depending on whether or not they check XML documents for validity. A processor that discovers a validity error must be able to report it, but may continue normal processing.  A DTD is an example of a  schema  or grammar . Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships.   [ edit ]  DTD   Main article: Document Type Definition   The oldest schema language for XML is the Document Type Definition (DTD), inherited from SGML .  DTDs have the following benefits:   DTD support is ubiquitous due to its inclusion in the XML 1.0 standard.  DTDs are terse compared to element-based schema languages and consequently present more information in a single screen.  DTDs allow the declaration of standard public entity sets for publishing characters.  DTDs define a document type rather than the types used by a namespace, thus grouping all constraints for a document in a single collection.   DTDs have the following limitations:   They have no explicit support for newer features of XML, most importantly namespaces .  They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes.  They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual macros ), which make it easier to define complex grammars, but at the expense of clarity.  They use a syntax based on regular expression syntax, inherited from SGML , to describe the schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.   Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining entities , which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes.  DTD technology is still used in many applications because of its ubiquity.   [ edit ]  XML Schema   Main article: XML Schema (W3C)   A newer schema language, described by the W3C as the successor of DTDs, is XML Schema , often referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system and allow for more detailed constraints on an XML document&apos;s logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them.   [ edit ]  RELAX NG   Main article: RELAX NG    RELAX NG was initially specified by OASIS and is now also an ISO/IEC International Standard (as part of DSDL ). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are isomorphic and James Clark &apos;s Trang conversion tool can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins ; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.   [ edit ]  Schematron   Main article: Schematron    Schematron is a language for making assertions about the presence or absence of patterns in an XML document. It typically uses XPath expressions.   [ edit ]  ISO DSDL and other schema languages   The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing .  Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the infoset augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these.   [ edit ]  Related specifications   A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0. It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core.    XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces.   XML Base defines the xml:base attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element.  The XML Information Set or XML infoset describes an abstract data model for XML documents in terms of information items . The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow.  xml:id Version 1.0 asserts that an attribute named xml:id functions as an &quot;ID attribute&quot; in the sense used in a DTD.   XPath defines a syntax named XPath expressions which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document. XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data.   XSLT is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes.   XSL Formatting Objects , or XSL-FO, is a markup language for XML document formatting which is most often used to generate PDFs .   XQuery is an XML-oriented query language strongly rooted in XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for XML databases .   XML Signature defines syntax and processing rules for creating digital signatures on XML content.   XML Encryption defines syntax and processing rules for encrypting XML content.   Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including XInclude , XLink , and XPointer .   [ edit ]  Use on the Internet   XML has come into common use for the interchange of data over the Internet. RFC 3023 gives rules for the construction of Internet Media Types for use when sending XML. It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data are in XML, and nothing about its semantics . The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.   [ 3 ]    RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for SVG .  Further guidelines for the use of XML in a networked context may be found in RFC 3470 , also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language.  XML can also form a crucial part of a databaseless design .   [ edit ]  Programming interfaces   The design goals of XML include, &quot;It shall be easy to write programs which process XML documents.&quot;   [ 6 ]   Despite this, the XML specification contains almost no information about how programmers might go about doing such processing. The XML Infoset specification provides a vocabulary to refer to the constructs within an XML document, but also does not provide any guidance on how to access this information. A variety of APIs for accessing XML have been developed and used, and some have been standardized.  Existing APIs for XML processing tend to fall into these categories:   Stream-oriented APIs accessible from a programming language, for example SAX and StAX .  Tree-traversal APIs accessible from a programming language, for example DOM .   XML data binding , which provides an automated translation between an XML document and programming-language objects.  Declarative transformation languages such as XSLT and XQuery .   Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives. Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions.  XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large XML databases .   [ edit ]  Simple API for XML (SAX)    SAX is a lexical , event-driven interface in which a document is read serially and its contents are reported as callbacks to various methods on a handler object of the user&apos;s design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.   [ edit ]  Pull parsing   Pull parsing   [ 17 ]   treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLReader in PHP and System.Xml.XmlReader in the .NET Framework .  A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace , values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code..   [ edit ]  Document Object Model   The Document Object Model (DOM) is an interface -oriented application programming interface that allows for navigation of the entire document as if it were a tree of node  objects representing the document&apos;s contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings . DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.   [ edit ]  Data binding   Another form of XML processing API is XML data binding , where XML data are made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB) and XML Serialization in .NET.   [ 18 ]      [ edit ]  XML as data type   XML is beginning to appear as a first-class data type in other languages. The ECMAScript for XML (E4X) extension to the ECMAScript /JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.   [ 19 ]   E4X is supported by the Mozilla 2.5+ browsers and Adobe Actionscript , but has not been adopted more universally. Similar notations are used in Microsoft&apos;s LINQ implementation for Microsoft .NET 3.5 and above, and in Scala (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the&lt;[ ]&gt;notation.   [ 20 ]   The Resource Description Framework defines a data type rdf:XMLLiteral to hold wrapped, canonical XML .   [ 21 ]      [ edit ]  History   XML is an application profile of SGML (ISO 8879).   [ 22 ]     The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.   [ 23 ]      [ 24 ]   By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web , and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C&apos;s activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.   [ 25 ]     XML was compiled by a working group of eleven members,   [ 26 ]   supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.   [ 27 ]    James Clark served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty /&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen . Halfway through the project Bray accepted a consulting engagement with Netscape , provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft&apos;s Jean Paoli as a third co-editor.  The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in a short burst of intense work between August and November 1996   [ 28 ]   , when the first Working Draft of an XML specification was published.   [ 29 ]   Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998.   [ edit ]  Sources    XML is a profile of an ISO standard SGML , and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ( processing instructions ), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set ).  Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and HTML , in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP ) metadata accompanied the resource rather than being needed at the declaration of a link. The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0&apos;s naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime .  Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;   [ 30 ]   the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System.   [ edit ]  Versions   There are two current versions of XML. The first ( XML 1.0 ) was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use.  The second ( XML 1.1 ) was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,   [ 31 ]   and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.   [ 32 ]   The main changes are to enable the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.   [ 33 ]     Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the Unicode standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces redundancy . The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the Balinese , Cham , or Phoenician scripts among many others which have been added to Unicode since Unicode 3.2.   [ 32 ]     Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references   [ 34 ]   ). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.  There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for skunkworks ), written by one of the original developers of XML,   [ 35 ]   contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces , XML Base and XML Information Set ( infoset ) into the base standard.  The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name  Fast Infoset  for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).   [ edit ]  Criticism   XML and its extensions have regularly been criticized for verbosity and complexity.   [ 36 ]   Mapping the basic tree model of XML to type systems of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a self-describing language   [ 37 ]   (though the XML specification itself makes no such claim). JSON and YAML are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents.   [ edit ]  See also     List of XML markup languages    Comparison of layout engines (XML)    Binary XML    EBML    WBXML    Category:XML    Category:XML-based standards    Billion laughs (a denial-of-service attack on XML parsers)   XML Protocol    Comparison of data serialization formats     [ edit ]  References       ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 9–11 . http://tools.ietf.org/html/rfc3023#section-3.2   . Retrieved 2010-01-04 .          ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 7–9 . http://tools.ietf.org/html/rfc3023#section-3.1   . Retrieved 2010-01-04 .        ^    a        b     M. Murata, D. Kohn, and C. Lilley (2009-09-24). &quot;Internet Drafts: XML Media Types&quot; . IETF . http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03   . Retrieved 2010-06-10 .          ^    &quot;XML 1.0 Specification&quot; . W3.org . http://www.w3.org/TR/REC-xml   . Retrieved 2010-08-22 .          ^    &quot;W3C DOCUMENT LICENSE&quot;  . http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231  .        ^    a        b      &quot;XML 1.0 Origin and Goals&quot;  . http://www.w3.org/TR/REC-xml/#sec-origin-goals   . Retrieved July 2009 .          ^    &quot;XML Applications and Initiatives&quot;  . http://xml.coverpages.org/xmlApplications.html  .          ^    &quot;Introduction to iWork Programming Guide. Mac OS X Reference Library&quot; . Apple . http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html  .          ^    &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot; . W3.org . http://www.w3.org/TR/2006/REC-xml-20060816/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Characters vs. Bytes&quot;  . http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF  .          ^    &quot;Autodetection of Character Encodings&quot;  . http://www.w3.org/TR/REC-xml/#sec-guessing  .          ^  It is allowed, but not recommended, to use &quot;&lt;&quot; in XML entity values: Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition     ^    &quot;W3C I18N FAQ: HTML, XHTML, XML and Control Codes&quot;  . http://www.w3.org/International/questions/qa-controls  .          ^   http://web.archive.org/web/20110726002036/http://diveintomark.org/archives/2004/01/16/draconianism     ^   http://web.archive.org/web/20110514120305/http://diveintomark.org/archives/2004/01/08/postels-law     ^   Push, Pull, Next! by Bob DuCharme, at XML.com    ^    &quot;XML Serialization in the .NET Framework&quot; . Msdn.microsoft.com . http://msdn.microsoft.com/en-us/library/ms950721.aspx   . Retrieved 2009-07-31 .          ^    &quot;Processing XML with E4X&quot; . Mozilla Developer Center . Mozilla Foundation . https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x  .          ^    &quot;XML Shell: Core Syntax&quot; . xmlsh. 2010-05-13 . http://www.xmlsh.org/CoreSyntax   . Retrieved 2010-08-22 .          ^    &quot;Resource Description Framework (RDF): Concepts and Abstract Syntax&quot; . W3.org . http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral   . Retrieved 2010-08-22 .          ^    ISO/IEC 19757-3 . ISO / IEC . 1 June 2006. p. vi          ^   Bray, Tim (February 2005). &quot;A conversation with Tim Bray: Searching for ways to tame the world&apos;s vast stores of information&quot; . Association for Computing Machinery&apos;s &quot;Queue site&quot; . http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282   . Retrieved April 16, 2006 .          ^   edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley. (1988). &quot;Publishers, multimedia, and interactivity&quot;. Interactive multimedia . Cobb Group. ISBN   1-55615-124-1 .          ^   Eliot Kimber (2006). &quot;XML is 10&quot;  . http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html  .          ^  The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210 .    ^    &quot;Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG&quot; . W3.org . http://www.w3.org/XML/9712-reports.html   . Retrieved 2009-07-31 .          ^  Jon Bosak: The Birth of XML     ^    &quot;Extensible Markup Language (XML)&quot; . W3.org. 1996-11-14 . http://www.w3.org/TR/WD-xml-961114.html   . Retrieved 2009-07-31 .          ^   Jon Bosak, Sun Microsystems (2006-12-07). &quot;Closing Keynote, XML 2006&quot; . 2006.xmlconference.org . http://2006.xmlconference.org/proceedings/162/presentation.html   . Retrieved 2009-07-31 .          ^    &quot;Extensible Markup Language (XML) 1.0 (Third Edition)&quot; . W3.org . http://www.w3.org/TR/2004/REC-xml-20040204   . Retrieved 2010-08-22 .        ^    a        b      &quot;Extensible Markup Language (XML) 1.1 (Second Edition) – Rationale and list of changes for XML 1.1&quot; . W3C . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2012-01-20 .          ^   Harold, Elliotte Rusty (2004).  Effective XML  . Addison-Wesley. pp. 10–19. ISBN   0321150406  . http://www.cafeconleche.org/books/effectivexml/  .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2010-08-22 .          ^  Tim Bray:  Extensible Markup Language - SW (XML-SW) . 2002-02-10    ^  Jeff Atwood (2009): XML: The Angle Bracket Tax     ^  Eric Brown (2003): The Myth of Self-Describing XML      [ edit ]  Further reading    Annex A of ISO 8879:1986 (SGML)   Lawrence A. Cunningham (2005). &quot;Language, Deals and Standards: The Future of XML Contracts&quot;. Washington University Law Review . SSRN   900616 .         Bosak, Jon; Tim Bray (May 1999). &quot;XML and the Second-Generation Web&quot;. Scientific American .      Online at XML and the Second-Generation Web .    Kelly, Sean (February 6, 2006). &quot;Making Mistakes with XML&quot; . Developer.com  . http://www.developer.com/xml/article.php/10929_3583081_1   . Retrieved 2010-10-26 .         Ogbuji, Uche (14 Nov 2006). &quot;Thinking XML: The XML decade&quot; . developerWorks . IBM  . http://www-128.ibm.com/developerworks/library/x-think38.html   . Retrieved 2010-10-26 .         St. Laurent, Simon (February 12, 2003). &quot;Five years later, XML..&quot; . O&apos;Reilly XML Blog . O&apos;Reilly Media  . http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html   . Retrieved 2010-10-26 .          &quot;W3C XML is Ten!&quot; . World Wide Web Consortium . 12 February 2008 . http://www.w3.org/2008/02/xml10-pressrelease   . Retrieved 2010-10-26 .         Flynn, Peter [ed] (5 January 2011). &quot;The XML FAQ&quot; . Cork: Silmaril . http://xml.silmaril.ie/  .          [ edit ]  External links        Wikimedia Commons has media related to:   XML            Wikibooks has more on the topic of    XML               This article&apos;s use of external links may not follow Wikipedia&apos;s policies or guidelines . Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references   (November 2010)        W3C XML homepage    XML 1.0 Specification    Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe    XML, Java and the Future of the Web by Jon Bosak    XML.gov    XML: Ten year anniversary by Elliot Kimber   23 XML fallacies to watch out for by Sean McGrath   XML Injection - Web Application Security Consortium                v      d      e       World Wide Web Consortium          Products and standards         Recommendations        Canonical XML    CDF    CSS    DOM    Geolocation API    HTML    ITS    MathML    OWL    P3P    PLS    RDF    RDF Schema    SISR    SKOS    SMIL    SOAP    SRGS    SSML    SVG    SPARQL    Timed Text    VoiceXML    WSDL    XForms    XHTML    XHTML+RDFa    XInclude    XLink    XML    XML Base    XML Encryption    XML Events    XML Information Set    XML namespace    XML Schema    XML Signature    XPath  1.0 , 2.0    XPointer    XProc    XQuery    XSL    XSL-FO    XSLT  ( elements )             Notes       XAdES    XHTML+SMIL    XUP             Working Drafts       CCXML    CURIE    HTML5    InkML    RIF    SCXML    SMIL Timesheets    sXBL    WICD    XFDL    XFrames    XBL    XHTML+MathML+SVG    XMLHttpRequest             Guidelines       Web Content Accessibility Guidelines             Initiative       Multimodal Interaction Activity    Markup Validation Service    Web Accessibility Initiative             Deprecated       C-HTML    HDML    JSSS    PGML    VML               Organizations      World Wide Web Foundation    SVG Working Group    WebOnt    W3C Device Description Working Group    WHATWG            Software      Agora    Argo    Arena    Amaya    CERN httpd    Libwww    Line Mode Browser            Conference-related      IW3C2    World Wide Web Conference    WWW1            Retrieved from &quot; http://en.wikipedia.org/w/index.php?title=XML&amp;oldid=472314787 &quot;    Categories :   XML    Markup languages    World Wide Web Consortium standards    Technical communication    Bibliography file formats    Computer file formats    Open formats    Data modeling languages    Data serialization formats    Application layer protocols    Presentation layer protocols     Hidden categories:   Articles containing potentially dated statements from 2009    All articles containing potentially dated statements    Wikipedia external links cleanup from November 2010    Wikipedia spam cleanup from November 2010            Personal tools    Log in / create account       Namespaces     Article      Talk        Variants             Views     Read      Edit      View history        Actions            Search                     Navigation     Main page    Contents    Featured content    Current events    Random article    Donate to Wikipedia       Interaction     Help    About Wikipedia    Community portal    Recent changes    Contact Wikipedia       Toolbox     What links here    Related changes    Upload file    Special pages    Permanent link    Cite this page       Print/export     Create a book    Download as PDF    Printable version       Languages     Afrikaans    العربية    Azərbaycanca    বাংলা    Bosanski    Български    Català    Česky    Dansk    Deutsch    Eesti    Ελληνικά    Español    Esperanto    Euskara    فارسی    Français    Gaeilge    Galego    한국어    हिन्दी    Hrvatski    Bahasa Indonesia    Interlingua    Íslenska    Italiano    עברית    ລາວ    Latviešu    Lietuvių    Magyar    Македонски    മലയാളം    Bahasa Melayu    Монгол    Nederlands    日本語    ‪Norsk (bokmål)‬    ‪Norsk (nynorsk)‬    Polski    Português    Română    Русский    Shqip    Simple English    Slovenčina    Slovenščina    کوردی    Српски / Srpski    Srpskohrvatski / Српскохрватски    Suomi    Svenska    தமிழ்    తెలుగు    ไทย    Тоҷикӣ    Türkçe    Türkmençe    Українська    اردو    Tiếng Việt    Žemaitėška    中文         This page was last modified on 20 January 2012 at 20:09.   Text is available under the Creative Commons Attribution-ShareAlike License   ;
additional terms may apply.
See Terms of use for details. Wikipedia&amp;reg;is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization.    Contact us      Privacy policy    About Wikipedia    Disclaimers    Mobile view                          
  </body>


  <title> How Much Food Do I Feed My Dog — Dr. Gregs Dog Dish Diet</title>
  <body>
&apos;      Home    Order Dog Dish Diet Now!    Testimonials    Who is Dr. Greg?    Contact Dr. Greg    PDF Introduction to Crock Pot Cooking Access With Purchase    Dog Dish Diet Videos              How Much Dry Food Should I Feed My Dog?  by Dr Greg on July 24, 2011           In my book, Dog Dish Diet, I go over the calories in dry and canned food and the amount of daily calories a dog should be fed. However, most people use a scoop or their hand to measure dry food. If your dog looks good…no need to change your methods. If your dog is on the chunky side, overweight, or grossly fat you need to measure out the food you feed them. You may also want to consider diluting  the calories in dry food with water or green beans, or feeding something with less carbohydrate calories like canned food,  home cooked food, or a piece of chicken 2-3 nights per week instead of dry food or kibble. Dog Dish Diet teaches us to feed better by learning about ingredients. Some dogs are suffering and dying because they can’t tolerate the ingredients in some commercial foods.( chronic skin problems, ear problems , bladder infections and stones , seizures, diarrhea, diabetes, fatty tumors to name a few)   If your dog has skin, ear, bowel, bladder, or seizure problems consider the Dog Dish Diet and feed your pet to avoid the vet!    Here is a question I received on facebook today:    Doc.. about how much of the chicken stew would a 50lb dog and 80lb dog need daily if the diet was to be changed from dry to this.. of course it would be a gradual change not to upset tummies…    My Answer:          My 80 lb lab eats about 12 oz twice daily. My 10 lb terrier mix eats 6 oz twice daily. My 10 pound bichon/poodle cross eats 6 oz twice daily. You can see that my small dogs need to eat more ounces per pound. In general, dogs need 10-50 calories per pound per day depending on their individual metabolism and energy level.(how much fuel they burn during their normal daily activities)Your  50 pound dog needs anywhere from 500-2500 calories per day depending on activity level. I usually assume 10-20 cal/pound/day for medium to large breeds, 20-30 cal/ pound /day for medium dogs, and 30-40 cal/pound /day for small active dogs. So the stew is 35 calories per ounce, and if 1000 calories needed, about 30 ounces (15 ounces twice daily). The bigger dogs often need less per pound than medium and small dogs unless they move a lot. The 80 pound would get the same or 25 ounces once daily (12 ounces twice daily). Many clients add the stew to moistened dry food as a supplement. One cup 2-3 times a week.      Dry food is usually 45 calories per ounce, canned food is roughly 25 calories per ounce. An 80 pound overweight dog may only need 800 calories per day because they are a slug. This would be about 18 ounces of dry food(2 cups)(or and no hi carb treats!!      Some dogs can’t handle the carbs in dry food or kibble. They gain weight no matter how little dry food they are given. They develop lipomas or fatty tumors. They have dry, flaky, skin. They need more protein, fats, and oils in their diet. Don’t keep feeding the same type of dry, high carbohydrate, low fat food and expect different results. Feed your pet to avoid the vet!!                Leave a Comment      Name *      E-mail *      Website                   Previous post: Temporary Home Remedies for Ear Infections   Next post: Why Does My Dog Eat Poop?                Find more at MindBites, the how-to video marketplace !      Always be among the first to know      Want more articles like the ones to the left?
For your convenience, I’ll send my latest posts directly to your inbox. Sign up now…it’s simple.                    Name:       Email:                             Order your special autographed copy now!           Archives    January 2012    December 2011    November 2011    October 2011    September 2011    August 2011    July 2011    June 2011    May 2011    April 2011    March 2011    February 2011    January 2011    December 2010    November 2010    October 2010    September 2010    August 2010    July 2010    June 2010    May 2010    April 2010    March 2010    February 2010    January 2010    December 2009    November 2009    October 2009    September 2009    August 2009    July 2009    June 2009             Receive your  FREE Copy of Dr. Greg&apos;s 11 Practical Home Remedies for Your Dog              Name  &amp;nbsp;     Email  &amp;nbsp;                  Dog Dish Diet Wins Gold Medal, 2010 Living Now Book Award         Dog Dish Diet Honored with a 2010 Indie Excellence Award         Dog Dish Diet Receives 2010 Next Generation Book Award, Finalist         Dog Dish Diet Wins 2010 San Francisco Book Festival, Honorable Mention                         Tags   California  california veterinarian  canine flu  canine health  canine nutrition  canine vaccines  canine viruses  cat food  cat health  cats  changing do habits  dog bones  Dog Dish Diet  dog food  dog food allergies  dog health  dog nutrition  dog tumors  Dr. Greg  Dr. Greg&apos;s Dog Dish Diet  ear problems in dogs  funny animal story  Gilroy  Gilroy Today  glucosamine  Greg Martinez DVM  healthy dog food  healthy dog snack  healthy eating for cats  healthy eating for dogs  joint pain  neutraceuticals  Omega 3  OPC  overweight cats  parrot  parvo  people food for dogs  pets  pet safety  poisons  radio broadcast  tick-borne diseases  ticks  veterinarian           Dog Dish Diet on Facebook          © 2011 Greg Martinez, DVM   WordPress Admin         
  </body>


  <title> XML - Wikipedia, the free encyclopedia</title>
  <body>
            XML   From Wikipedia, the free encyclopedia    Jump to: navigation , search        XML           Filename extension    .xml      Internet media type    application/xml ,   [ 1 ]     text/xml    [ 2 ]   (deprecated in an expired draft)   [ 3 ]        Uniform Type Identifier   public.xml    UTI conforms to  public.text    Developed by   World Wide Web Consortium     Type of format   Markup language     Extended from   SGML     Extended to   Numerous , including:  XHTML , RSS , Atom , KML      Standard(s)    1.0 (Fifth Edition) November 26, 2008 ; 3 years ago   ( 2008-11-26 )   1.1 (Second Edition) August 16, 2006 ; 5 years ago   ( 2006-08-16 )      Open format ?  Yes      Extensible Markup Language (XML)    Current Status  Published    Year Started  1996    Editors  Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan    Related Standards   XML Schema     Domain   Data Serialization     Abbreviation  XML    Website   XML 1.0         Extensible Markup Language ( XML ) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable . It is defined in the XML 1.0 Specification   [ 4 ]   produced by the W3C , and several other related specifications, all gratis  open standards .   [ 5 ]     The design goals of XML emphasize simplicity, generality, and usability over the Internet .   [ 6 ]   It is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary data structures , for example in web services .  Many application programming interfaces (APIs) have been developed for software developers to use to process XML data, and several schema systems exist to aid in the definition of XML-based languages.  As of 2009  [update]  , hundreds of XML-based languages have been developed,   [ 7 ]   including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for many office-productivity tools, including Microsoft Office ( Office Open XML ), OpenOffice.org ( OpenDocument ), and Apple &apos;s iWork .   [ 8 ]   XML has also been employed as the base language for communication protocols , such as XMPP .      Contents      1  Key terminology      2  Characters and escaping      2.1  Valid characters      2.2  Encoding detection      2.3  Escaping      2.4  Comments      2.5  International use        3  Well-formedness and error-handling      4  Schemas and validation      4.1  DTD      4.2  XML Schema      4.3  RELAX NG      4.4  Schematron      4.5  ISO DSDL and other schema languages        5  Related specifications      6  Use on the Internet      7  Programming interfaces      7.1  Simple API for XML (SAX)      7.2  Pull parsing      7.3  Document Object Model      7.4  Data binding      7.5  XML as data type        8  History      8.1  Sources      8.2  Versions        9  Criticism      10  See also      11  References      12  Further reading      13  External links         [ edit ]  Key terminology   The material in this section is based on the XML Specification. This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use.   (Unicode) Character  By definition, an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document.    Processor and Application  The processor analyzes the markup and passes structured information to an application . The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an XML parser .    Markup and Content  The characters which make up an XML document are divided into markup and content . Markup and content may be distinguished by the application of simple syntactic rules. All strings which constitute markup either begin with the character &quot;&lt;&quot; and end with a &quot;&gt;&quot;, or begin with the character &quot;&amp;&quot; and end with a &quot;;&quot;. Strings of characters which are not markup are content.    Tag  A markup construct that begins with &quot;&lt;&quot; and ends with &quot;&gt;&quot;. Tags come in three flavors: start-tags , for example &lt;section&gt; , end-tags , for example &lt;/section&gt; , and empty-element tags , for example &lt;line-break /&gt; .    Element  A logical document component either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start- and end-tags, if any, are the element&apos;s content , and may contain markup, including other elements, which are called child elements . An example of an element is &lt;Greeting&gt;Hello, world.&lt;/Greeting&gt; (see hello world ). Another is &lt;line-break /&gt; .    Attribute  A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag. In the example (below) the element img has two attributes, src and alt : &lt;img src=&quot;madonna.jpg&quot; alt=&apos;Foligno Madonna, by Raphael&apos; /&gt; . Another example would be &lt;step number=&quot;3&quot;&gt;Connect A to B.&lt;/step&gt; where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;.    XML Declaration  XML documents may begin by declaring some information about themselves, as in the following example.       &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;       [ edit ]  Characters and escaping   XML documents consist entirely of characters from the Unicode repertoire. Except for a small number of specifically excluded control characters , any character defined by Unicode may appear within the content of an XML document. The selection of characters that may appear within markup is somewhat more limited but still large.  XML includes facilities for identifying the encoding of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly.   [ edit ]  Valid characters   Main article: Valid characters in XML   Unicode code points in the following ranges are valid in XML 1.0 documents:   [ 9 ]      U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0;  U+0020–U+D7FF, U+E000–U+FFFD: this excludes some (not all) non-characters in the BMP (all surrogates, U+FFFE and U+FFFF are forbidden);  U+10000–U+10FFFF: this includes all code points in supplementary planes, including non-characters.   XML 1.1   [ 10 ]   extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001–U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as&amp;#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected.  The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document.   [ edit ]  Encoding detection   The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;. Unicode itself defines encodings that cover the entire repertoire; well-known ones include UTF-8 and UTF-16 .   [ 11 ]   There are many other text encodings that pre-date Unicode, such as ASCII and ISO/IEC 8859 ; their character repertoires in almost every case are subsets of the Unicode character set.  XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.   [ 12 ]   Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser.   [ edit ]  Escaping   XML provides  escape  facilities for including characters which are problematic to include directly. For example:   The characters &quot;&lt;&quot; and &quot;&amp;&quot; are key syntax markers and may never appear in content outside of a CDATA section.   [ 13 ]     Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;é&quot;.  It might not be possible to type the character on the author&apos;s machine.  Some characters have glyphs that cannot be visually distinguished from other characters: examples are  non-breaking-space ( &amp;#xa0; ) &quot; &quot;  compare space ( &amp;#x20; ) &quot; &quot;    Cyrillic Capital Letter A ( &amp;#x410; ) &quot;А&quot;  compare Latin Capital Letter A ( &amp;#x61; ) &quot;A&quot;       There are five predefined entities :    &amp;lt; represents &quot;&lt;&quot;   &amp;gt; represents &quot;&gt;&quot;   &amp;amp; represents &quot;&amp;&quot;   &amp;apos; represents &apos;   &amp;quot; represents &quot;   All permitted Unicode characters may be represented with a  numeric character reference  . Consider the Chinese character &quot;中&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013. A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as &amp;#20013; or &amp;#x4e2d; . Similarly, the string &quot; I&lt;3 Jörg &quot; could be encoded for inclusion in an XML document as &quot; I&amp;lt;3 J&amp;#xF6;rg &quot;.  &quot; &amp;#0; &quot; is not permitted, however, because the null character is one of the control characters excluded from XML, even when using a numeric character reference.   [ 14 ]   An alternative encoding mechanism such as Base64 is needed to represent such characters.   [ edit ]  Comments   Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot; -- &quot; (double-hyphen) is not allowed inside comments. Comments start with &quot;&lt;!--&quot;. The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding.  An example of a valid comment: &quot; &lt;!-- no need to escape&lt;code&gt;&amp;such in comments --&gt; &quot;   [ edit ]  International use         This example contains Chinese text. Without proper rendering support , you may see question marks, boxes, or other symbols instead of Chinese characters .          This example contains Cyrillic text . Without proper rendering support , you may see question marks or boxes , misplaced vowels or missing conjuncts instead of Cyrillic letters.    XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&lt;&quot;). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters:      &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;   &lt;俄语 &gt;  данные &lt;/俄语 &gt;       [ edit ]  Well-formedness and error-handling   Main article: Well-formed document   The XML specification defines an XML document as a text that is well-formed , i.e. it satisfies a list of syntax rules provided in the specification. The list is fairly lengthy; some key points are:   It contains only properly encoded legal Unicode characters.  None of the special syntax characters such as &quot;&lt;&quot; and &quot;&amp;&quot; appear except when performing their markup-delineation roles.  The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping.  The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters !&quot;#$%&amp;&apos;()*+,/;&lt;=&gt;?@[\]^`{|}~, nor a space character, and cannot start with -, ., or a numeric digit.  There is a single &quot;root&quot; element that contains all the other elements.   The definition of an XML document excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as draconian , stands in notable contrast to the behavior of programs that process HTML , which are designed to produce a reasonable result even in the presence of severe markup errors.   [ 15 ]   XML&apos;s policy in this area has been criticized as a violation of Postel&apos;s law (&quot;Be conservative in what you send; be liberal in what you accept&quot;).   [ 16 ]      [ edit ]  Schemas and validation   In addition to being well-formed, an XML document may be valid . This means that it contains a reference to a Document Type Definition (DTD) , and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies.  XML processors are classified as validating or non-validating depending on whether or not they check XML documents for validity. A processor that discovers a validity error must be able to report it, but may continue normal processing.  A DTD is an example of a  schema  or grammar . Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships.   [ edit ]  DTD   Main article: Document Type Definition   The oldest schema language for XML is the Document Type Definition (DTD), inherited from SGML .  DTDs have the following benefits:   DTD support is ubiquitous due to its inclusion in the XML 1.0 standard.  DTDs are terse compared to element-based schema languages and consequently present more information in a single screen.  DTDs allow the declaration of standard public entity sets for publishing characters.  DTDs define a document type rather than the types used by a namespace, thus grouping all constraints for a document in a single collection.   DTDs have the following limitations:   They have no explicit support for newer features of XML, most importantly namespaces .  They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes.  They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual macros ), which make it easier to define complex grammars, but at the expense of clarity.  They use a syntax based on regular expression syntax, inherited from SGML , to describe the schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.   Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining entities , which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes.  DTD technology is still used in many applications because of its ubiquity.   [ edit ]  XML Schema   Main article: XML Schema (W3C)   A newer schema language, described by the W3C as the successor of DTDs, is XML Schema , often referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system and allow for more detailed constraints on an XML document&apos;s logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them.   [ edit ]  RELAX NG   Main article: RELAX NG    RELAX NG was initially specified by OASIS and is now also an ISO/IEC International Standard (as part of DSDL ). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are isomorphic and James Clark &apos;s Trang conversion tool can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins ; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.   [ edit ]  Schematron   Main article: Schematron    Schematron is a language for making assertions about the presence or absence of patterns in an XML document. It typically uses XPath expressions.   [ edit ]  ISO DSDL and other schema languages   The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing .  Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the infoset augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these.   [ edit ]  Related specifications   A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0. It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core.    XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces.   XML Base defines the xml:base attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element.  The XML Information Set or XML infoset describes an abstract data model for XML documents in terms of information items . The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow.  xml:id Version 1.0 asserts that an attribute named xml:id functions as an &quot;ID attribute&quot; in the sense used in a DTD.   XPath defines a syntax named XPath expressions which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document. XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data.   XSLT is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes.   XSL Formatting Objects , or XSL-FO, is a markup language for XML document formatting which is most often used to generate PDFs .   XQuery is an XML-oriented query language strongly rooted in XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for XML databases .   XML Signature defines syntax and processing rules for creating digital signatures on XML content.   XML Encryption defines syntax and processing rules for encrypting XML content.   Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including XInclude , XLink , and XPointer .   [ edit ]  Use on the Internet   XML has come into common use for the interchange of data over the Internet. RFC 3023 gives rules for the construction of Internet Media Types for use when sending XML. It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data are in XML, and nothing about its semantics . The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.   [ 3 ]    RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for SVG .  Further guidelines for the use of XML in a networked context may be found in RFC 3470 , also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language.  XML can also form a crucial part of a databaseless design .   [ edit ]  Programming interfaces   The design goals of XML include, &quot;It shall be easy to write programs which process XML documents.&quot;   [ 6 ]   Despite this, the XML specification contains almost no information about how programmers might go about doing such processing. The XML Infoset specification provides a vocabulary to refer to the constructs within an XML document, but also does not provide any guidance on how to access this information. A variety of APIs for accessing XML have been developed and used, and some have been standardized.  Existing APIs for XML processing tend to fall into these categories:   Stream-oriented APIs accessible from a programming language, for example SAX and StAX .  Tree-traversal APIs accessible from a programming language, for example DOM .   XML data binding , which provides an automated translation between an XML document and programming-language objects.  Declarative transformation languages such as XSLT and XQuery .   Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives. Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions.  XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large XML databases .   [ edit ]  Simple API for XML (SAX)    SAX is a lexical , event-driven interface in which a document is read serially and its contents are reported as callbacks to various methods on a handler object of the user&apos;s design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.   [ edit ]  Pull parsing   Pull parsing   [ 17 ]   treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLReader in PHP and System.Xml.XmlReader in the .NET Framework .  A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace , values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code..   [ edit ]  Document Object Model   The Document Object Model (DOM) is an interface -oriented application programming interface that allows for navigation of the entire document as if it were a tree of node  objects representing the document&apos;s contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings . DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.   [ edit ]  Data binding   Another form of XML processing API is XML data binding , where XML data are made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB) and XML Serialization in .NET.   [ 18 ]      [ edit ]  XML as data type   XML is beginning to appear as a first-class data type in other languages. The ECMAScript for XML (E4X) extension to the ECMAScript /JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.   [ 19 ]   E4X is supported by the Mozilla 2.5+ browsers and Adobe Actionscript , but has not been adopted more universally. Similar notations are used in Microsoft&apos;s LINQ implementation for Microsoft .NET 3.5 and above, and in Scala (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the&lt;[ ]&gt;notation.   [ 20 ]   The Resource Description Framework defines a data type rdf:XMLLiteral to hold wrapped, canonical XML .   [ 21 ]      [ edit ]  History   XML is an application profile of SGML (ISO 8879).   [ 22 ]     The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.   [ 23 ]      [ 24 ]   By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web , and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C&apos;s activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.   [ 25 ]     XML was compiled by a working group of eleven members,   [ 26 ]   supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.   [ 27 ]    James Clark served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty /&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen . Halfway through the project Bray accepted a consulting engagement with Netscape , provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft&apos;s Jean Paoli as a third co-editor.  The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in a short burst of intense work between August and November 1996   [ 28 ]   , when the first Working Draft of an XML specification was published.   [ 29 ]   Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998.   [ edit ]  Sources    XML is a profile of an ISO standard SGML , and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ( processing instructions ), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set ).  Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and HTML , in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP ) metadata accompanied the resource rather than being needed at the declaration of a link. The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0&apos;s naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime .  Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;   [ 30 ]   the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System.   [ edit ]  Versions   There are two current versions of XML. The first ( XML 1.0 ) was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use.  The second ( XML 1.1 ) was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,   [ 31 ]   and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.   [ 32 ]   The main changes are to enable the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.   [ 33 ]     Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the Unicode standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces redundancy . The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the Balinese , Cham , or Phoenician scripts among many others which have been added to Unicode since Unicode 3.2.   [ 32 ]     Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references   [ 34 ]   ). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.  There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for skunkworks ), written by one of the original developers of XML,   [ 35 ]   contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces , XML Base and XML Information Set ( infoset ) into the base standard.  The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name  Fast Infoset  for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).   [ edit ]  Criticism   XML and its extensions have regularly been criticized for verbosity and complexity.   [ 36 ]   Mapping the basic tree model of XML to type systems of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a self-describing language   [ 37 ]   (though the XML specification itself makes no such claim). JSON and YAML are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents.   [ edit ]  See also     List of XML markup languages    Comparison of layout engines (XML)    Binary XML    EBML    WBXML    Category:XML    Category:XML-based standards    Billion laughs (a denial-of-service attack on XML parsers)   XML Protocol    Comparison of data serialization formats     [ edit ]  References       ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 9–11 . http://tools.ietf.org/html/rfc3023#section-3.2   . Retrieved 2010-01-04 .          ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 7–9 . http://tools.ietf.org/html/rfc3023#section-3.1   . Retrieved 2010-01-04 .        ^    a        b     M. Murata, D. Kohn, and C. Lilley (2009-09-24). &quot;Internet Drafts: XML Media Types&quot; . IETF . http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03   . Retrieved 2010-06-10 .          ^    &quot;XML 1.0 Specification&quot; . W3.org . http://www.w3.org/TR/REC-xml   . Retrieved 2010-08-22 .          ^    &quot;W3C DOCUMENT LICENSE&quot;  . http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231  .        ^    a        b      &quot;XML 1.0 Origin and Goals&quot;  . http://www.w3.org/TR/REC-xml/#sec-origin-goals   . Retrieved July 2009 .          ^    &quot;XML Applications and Initiatives&quot;  . http://xml.coverpages.org/xmlApplications.html  .          ^    &quot;Introduction to iWork Programming Guide. Mac OS X Reference Library&quot; . Apple . http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html  .          ^    &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot; . W3.org . http://www.w3.org/TR/2006/REC-xml-20060816/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Characters vs. Bytes&quot;  . http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF  .          ^    &quot;Autodetection of Character Encodings&quot;  . http://www.w3.org/TR/REC-xml/#sec-guessing  .          ^  It is allowed, but not recommended, to use &quot;&lt;&quot; in XML entity values: Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition     ^    &quot;W3C I18N FAQ: HTML, XHTML, XML and Control Codes&quot;  . http://www.w3.org/International/questions/qa-controls  .          ^   http://web.archive.org/web/20110726002036/http://diveintomark.org/archives/2004/01/16/draconianism     ^   http://web.archive.org/web/20110514120305/http://diveintomark.org/archives/2004/01/08/postels-law     ^   Push, Pull, Next! by Bob DuCharme, at XML.com    ^    &quot;XML Serialization in the .NET Framework&quot; . Msdn.microsoft.com . http://msdn.microsoft.com/en-us/library/ms950721.aspx   . Retrieved 2009-07-31 .          ^    &quot;Processing XML with E4X&quot; . Mozilla Developer Center . Mozilla Foundation . https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x  .          ^    &quot;XML Shell: Core Syntax&quot; . xmlsh. 2010-05-13 . http://www.xmlsh.org/CoreSyntax   . Retrieved 2010-08-22 .          ^    &quot;Resource Description Framework (RDF): Concepts and Abstract Syntax&quot; . W3.org . http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral   . Retrieved 2010-08-22 .          ^    ISO/IEC 19757-3 . ISO / IEC . 1 June 2006. p. vi          ^   Bray, Tim (February 2005). &quot;A conversation with Tim Bray: Searching for ways to tame the world&apos;s vast stores of information&quot; . Association for Computing Machinery&apos;s &quot;Queue site&quot; . http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282   . Retrieved April 16, 2006 .          ^   edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley. (1988). &quot;Publishers, multimedia, and interactivity&quot;. Interactive multimedia . Cobb Group. ISBN   1-55615-124-1 .          ^   Eliot Kimber (2006). &quot;XML is 10&quot;  . http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html  .          ^  The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210 .    ^    &quot;Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG&quot; . W3.org . http://www.w3.org/XML/9712-reports.html   . Retrieved 2009-07-31 .          ^  Jon Bosak: The Birth of XML     ^    &quot;Extensible Markup Language (XML)&quot; . W3.org. 1996-11-14 . http://www.w3.org/TR/WD-xml-961114.html   . Retrieved 2009-07-31 .          ^   Jon Bosak, Sun Microsystems (2006-12-07). &quot;Closing Keynote, XML 2006&quot; . 2006.xmlconference.org . http://2006.xmlconference.org/proceedings/162/presentation.html   . Retrieved 2009-07-31 .          ^    &quot;Extensible Markup Language (XML) 1.0 (Third Edition)&quot; . W3.org . http://www.w3.org/TR/2004/REC-xml-20040204   . Retrieved 2010-08-22 .        ^    a        b      &quot;Extensible Markup Language (XML) 1.1 (Second Edition) – Rationale and list of changes for XML 1.1&quot; . W3C . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2012-01-20 .          ^   Harold, Elliotte Rusty (2004).  Effective XML  . Addison-Wesley. pp. 10–19. ISBN   0321150406  . http://www.cafeconleche.org/books/effectivexml/  .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2010-08-22 .          ^  Tim Bray:  Extensible Markup Language - SW (XML-SW) . 2002-02-10    ^  Jeff Atwood (2009): XML: The Angle Bracket Tax     ^  Eric Brown (2003): The Myth of Self-Describing XML      [ edit ]  Further reading    Annex A of ISO 8879:1986 (SGML)   Lawrence A. Cunningham (2005). &quot;Language, Deals and Standards: The Future of XML Contracts&quot;. Washington University Law Review . SSRN   900616 .         Bosak, Jon; Tim Bray (May 1999). &quot;XML and the Second-Generation Web&quot;. Scientific American .      Online at XML and the Second-Generation Web .    Kelly, Sean (February 6, 2006). &quot;Making Mistakes with XML&quot; . Developer.com  . http://www.developer.com/xml/article.php/10929_3583081_1   . Retrieved 2010-10-26 .         Ogbuji, Uche (14 Nov 2006). &quot;Thinking XML: The XML decade&quot; . developerWorks . IBM  . http://www-128.ibm.com/developerworks/library/x-think38.html   . Retrieved 2010-10-26 .         St. Laurent, Simon (February 12, 2003). &quot;Five years later, XML..&quot; . O&apos;Reilly XML Blog . O&apos;Reilly Media  . http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html   . Retrieved 2010-10-26 .          &quot;W3C XML is Ten!&quot; . World Wide Web Consortium . 12 February 2008 . http://www.w3.org/2008/02/xml10-pressrelease   . Retrieved 2010-10-26 .         Flynn, Peter [ed] (5 January 2011). &quot;The XML FAQ&quot; . Cork: Silmaril . http://xml.silmaril.ie/  .          [ edit ]  External links        Wikimedia Commons has media related to:   XML            Wikibooks has more on the topic of    XML               This article&apos;s use of external links may not follow Wikipedia&apos;s policies or guidelines . Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references   (November 2010)        W3C XML homepage    XML 1.0 Specification    Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe    XML, Java and the Future of the Web by Jon Bosak    XML.gov    XML: Ten year anniversary by Elliot Kimber   23 XML fallacies to watch out for by Sean McGrath   XML Injection - Web Application Security Consortium                v      d      e       World Wide Web Consortium          Products and standards         Recommendations        Canonical XML    CDF    CSS    DOM    Geolocation API    HTML    ITS    MathML    OWL    P3P    PLS    RDF    RDF Schema    SISR    SKOS    SMIL    SOAP    SRGS    SSML    SVG    SPARQL    Timed Text    VoiceXML    WSDL    XForms    XHTML    XHTML+RDFa    XInclude    XLink    XML    XML Base    XML Encryption    XML Events    XML Information Set    XML namespace    XML Schema    XML Signature    XPath  1.0 , 2.0    XPointer    XProc    XQuery    XSL    XSL-FO    XSLT  ( elements )             Notes       XAdES    XHTML+SMIL    XUP             Working Drafts       CCXML    CURIE    HTML5    InkML    RIF    SCXML    SMIL Timesheets    sXBL    WICD    XFDL    XFrames    XBL    XHTML+MathML+SVG    XMLHttpRequest             Guidelines       Web Content Accessibility Guidelines             Initiative       Multimodal Interaction Activity    Markup Validation Service    Web Accessibility Initiative             Deprecated       C-HTML    HDML    JSSS    PGML    VML               Organizations      World Wide Web Foundation    SVG Working Group    WebOnt    W3C Device Description Working Group    WHATWG            Software      Agora    Argo    Arena    Amaya    CERN httpd    Libwww    Line Mode Browser            Conference-related      IW3C2    World Wide Web Conference    WWW1            Retrieved from &quot; http://en.wikipedia.org/w/index.php?title=XML&amp;oldid=472314787 &quot;    Categories :   XML    Markup languages    World Wide Web Consortium standards    Technical communication    Bibliography file formats    Computer file formats    Open formats    Data modeling languages    Data serialization formats    Application layer protocols    Presentation layer protocols     Hidden categories:   Articles containing potentially dated statements from 2009    All articles containing potentially dated statements    Wikipedia external links cleanup from November 2010    Wikipedia spam cleanup from November 2010            Personal tools    Log in / create account       Namespaces     Article      Talk        Variants             Views     Read      Edit      View history        Actions            Search                     Navigation     Main page    Contents    Featured content    Current events    Random article    Donate to Wikipedia       Interaction     Help    About Wikipedia    Community portal    Recent changes    Contact Wikipedia       Toolbox     What links here    Related changes    Upload file    Special pages    Permanent link    Cite this page       Print/export     Create a book    Download as PDF    Printable version       Languages     Afrikaans    العربية    Azərbaycanca    বাংলা    Bosanski    Български    Català    Česky    Dansk    Deutsch    Eesti    Ελληνικά    Español    Esperanto    Euskara    فارسی    Français    Gaeilge    Galego    한국어    हिन्दी    Hrvatski    Bahasa Indonesia    Interlingua    Íslenska    Italiano    עברית    ລາວ    Latviešu    Lietuvių    Magyar    Македонски    മലയാളം    Bahasa Melayu    Монгол    Nederlands    日本語    ‪Norsk (bokmål)‬    ‪Norsk (nynorsk)‬    Polski    Português    Română    Русский    Shqip    Simple English    Slovenčina    Slovenščina    کوردی    Српски / Srpski    Srpskohrvatski / Српскохрватски    Suomi    Svenska    தமிழ்    తెలుగు    ไทย    Тоҷикӣ    Türkçe    Türkmençe    Українська    اردو    Tiếng Việt    Žemaitėška    中文         This page was last modified on 20 January 2012 at 20:09.   Text is available under the Creative Commons Attribution-ShareAlike License   ;
additional terms may apply.
See Terms of use for details. Wikipedia&amp;reg;is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization.    Contact us      Privacy policy    About Wikipedia    Disclaimers    Mobile view                          
  </body>


  <title> How Much Food Do I Feed My Dog — Dr. Gregs Dog Dish Diet</title>
  <body>
&apos;      Home    Order Dog Dish Diet Now!    Testimonials    Who is Dr. Greg?    Contact Dr. Greg    PDF Introduction to Crock Pot Cooking Access With Purchase    Dog Dish Diet Videos              How Much Dry Food Should I Feed My Dog?  by Dr Greg on July 24, 2011           In my book, Dog Dish Diet, I go over the calories in dry and canned food and the amount of daily calories a dog should be fed. However, most people use a scoop or their hand to measure dry food. If your dog looks good…no need to change your methods. If your dog is on the chunky side, overweight, or grossly fat you need to measure out the food you feed them. You may also want to consider diluting  the calories in dry food with water or green beans, or feeding something with less carbohydrate calories like canned food,  home cooked food, or a piece of chicken 2-3 nights per week instead of dry food or kibble. Dog Dish Diet teaches us to feed better by learning about ingredients. Some dogs are suffering and dying because they can’t tolerate the ingredients in some commercial foods.( chronic skin problems, ear problems , bladder infections and stones , seizures, diarrhea, diabetes, fatty tumors to name a few)   If your dog has skin, ear, bowel, bladder, or seizure problems consider the Dog Dish Diet and feed your pet to avoid the vet!    Here is a question I received on facebook today:    Doc.. about how much of the chicken stew would a 50lb dog and 80lb dog need daily if the diet was to be changed from dry to this.. of course it would be a gradual change not to upset tummies…    My Answer:          My 80 lb lab eats about 12 oz twice daily. My 10 lb terrier mix eats 6 oz twice daily. My 10 pound bichon/poodle cross eats 6 oz twice daily. You can see that my small dogs need to eat more ounces per pound. In general, dogs need 10-50 calories per pound per day depending on their individual metabolism and energy level.(how much fuel they burn during their normal daily activities)Your  50 pound dog needs anywhere from 500-2500 calories per day depending on activity level. I usually assume 10-20 cal/pound/day for medium to large breeds, 20-30 cal/ pound /day for medium dogs, and 30-40 cal/pound /day for small active dogs. So the stew is 35 calories per ounce, and if 1000 calories needed, about 30 ounces (15 ounces twice daily). The bigger dogs often need less per pound than medium and small dogs unless they move a lot. The 80 pound would get the same or 25 ounces once daily (12 ounces twice daily). Many clients add the stew to moistened dry food as a supplement. One cup 2-3 times a week.      Dry food is usually 45 calories per ounce, canned food is roughly 25 calories per ounce. An 80 pound overweight dog may only need 800 calories per day because they are a slug. This would be about 18 ounces of dry food(2 cups)(or and no hi carb treats!!      Some dogs can’t handle the carbs in dry food or kibble. They gain weight no matter how little dry food they are given. They develop lipomas or fatty tumors. They have dry, flaky, skin. They need more protein, fats, and oils in their diet. Don’t keep feeding the same type of dry, high carbohydrate, low fat food and expect different results. Feed your pet to avoid the vet!!                Leave a Comment      Name *      E-mail *      Website                   Previous post: Temporary Home Remedies for Ear Infections   Next post: Why Does My Dog Eat Poop?                Find more at MindBites, the how-to video marketplace !      Always be among the first to know      Want more articles like the ones to the left?
For your convenience, I’ll send my latest posts directly to your inbox. Sign up now…it’s simple.                    Name:       Email:                             Order your special autographed copy now!           Archives    January 2012    December 2011    November 2011    October 2011    September 2011    August 2011    July 2011    June 2011    May 2011    April 2011    March 2011    February 2011    January 2011    December 2010    November 2010    October 2010    September 2010    August 2010    July 2010    June 2010    May 2010    April 2010    March 2010    February 2010    January 2010    December 2009    November 2009    October 2009    September 2009    August 2009    July 2009    June 2009             Receive your  FREE Copy of Dr. Greg&apos;s 11 Practical Home Remedies for Your Dog              Name  &amp;nbsp;     Email  &amp;nbsp;                  Dog Dish Diet Wins Gold Medal, 2010 Living Now Book Award         Dog Dish Diet Honored with a 2010 Indie Excellence Award         Dog Dish Diet Receives 2010 Next Generation Book Award, Finalist         Dog Dish Diet Wins 2010 San Francisco Book Festival, Honorable Mention                         Tags   California  california veterinarian  canine flu  canine health  canine nutrition  canine vaccines  canine viruses  cat food  cat health  cats  changing do habits  dog bones  Dog Dish Diet  dog food  dog food allergies  dog health  dog nutrition  dog tumors  Dr. Greg  Dr. Greg&apos;s Dog Dish Diet  ear problems in dogs  funny animal story  Gilroy  Gilroy Today  glucosamine  Greg Martinez DVM  healthy dog food  healthy dog snack  healthy eating for cats  healthy eating for dogs  joint pain  neutraceuticals  Omega 3  OPC  overweight cats  parrot  parvo  people food for dogs  pets  pet safety  poisons  radio broadcast  tick-borne diseases  ticks  veterinarian           Dog Dish Diet on Facebook          © 2011 Greg Martinez, DVM   WordPress Admin         
  </body>


  <title> XML - Wikipedia, the free encyclopedia</title>
  <body>
            XML   From Wikipedia, the free encyclopedia    Jump to: navigation , search        XML           Filename extension    .xml      Internet media type    application/xml ,   [ 1 ]     text/xml    [ 2 ]   (deprecated in an expired draft)   [ 3 ]        Uniform Type Identifier   public.xml    UTI conforms to  public.text    Developed by   World Wide Web Consortium     Type of format   Markup language     Extended from   SGML     Extended to   Numerous , including:  XHTML , RSS , Atom , KML      Standard(s)    1.0 (Fifth Edition) November 26, 2008 ; 3 years ago   ( 2008-11-26 )   1.1 (Second Edition) August 16, 2006 ; 5 years ago   ( 2006-08-16 )      Open format ?  Yes      Extensible Markup Language (XML)    Current Status  Published    Year Started  1996    Editors  Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan    Related Standards   XML Schema     Domain   Data Serialization     Abbreviation  XML    Website   XML 1.0         Extensible Markup Language ( XML ) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable . It is defined in the XML 1.0 Specification   [ 4 ]   produced by the W3C , and several other related specifications, all gratis  open standards .   [ 5 ]     The design goals of XML emphasize simplicity, generality, and usability over the Internet .   [ 6 ]   It is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary data structures , for example in web services .  Many application programming interfaces (APIs) have been developed for software developers to use to process XML data, and several schema systems exist to aid in the definition of XML-based languages.  As of 2009  [update]  , hundreds of XML-based languages have been developed,   [ 7 ]   including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for many office-productivity tools, including Microsoft Office ( Office Open XML ), OpenOffice.org ( OpenDocument ), and Apple &apos;s iWork .   [ 8 ]   XML has also been employed as the base language for communication protocols , such as XMPP .      Contents      1  Key terminology      2  Characters and escaping      2.1  Valid characters      2.2  Encoding detection      2.3  Escaping      2.4  Comments      2.5  International use        3  Well-formedness and error-handling      4  Schemas and validation      4.1  DTD      4.2  XML Schema      4.3  RELAX NG      4.4  Schematron      4.5  ISO DSDL and other schema languages        5  Related specifications      6  Use on the Internet      7  Programming interfaces      7.1  Simple API for XML (SAX)      7.2  Pull parsing      7.3  Document Object Model      7.4  Data binding      7.5  XML as data type        8  History      8.1  Sources      8.2  Versions        9  Criticism      10  See also      11  References      12  Further reading      13  External links         [ edit ]  Key terminology   The material in this section is based on the XML Specification. This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use.   (Unicode) Character  By definition, an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document.    Processor and Application  The processor analyzes the markup and passes structured information to an application . The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an XML parser .    Markup and Content  The characters which make up an XML document are divided into markup and content . Markup and content may be distinguished by the application of simple syntactic rules. All strings which constitute markup either begin with the character &quot;&lt;&quot; and end with a &quot;&gt;&quot;, or begin with the character &quot;&amp;&quot; and end with a &quot;;&quot;. Strings of characters which are not markup are content.    Tag  A markup construct that begins with &quot;&lt;&quot; and ends with &quot;&gt;&quot;. Tags come in three flavors: start-tags , for example &lt;section&gt; , end-tags , for example &lt;/section&gt; , and empty-element tags , for example &lt;line-break /&gt; .    Element  A logical document component either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start- and end-tags, if any, are the element&apos;s content , and may contain markup, including other elements, which are called child elements . An example of an element is &lt;Greeting&gt;Hello, world.&lt;/Greeting&gt; (see hello world ). Another is &lt;line-break /&gt; .    Attribute  A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag. In the example (below) the element img has two attributes, src and alt : &lt;img src=&quot;madonna.jpg&quot; alt=&apos;Foligno Madonna, by Raphael&apos; /&gt; . Another example would be &lt;step number=&quot;3&quot;&gt;Connect A to B.&lt;/step&gt; where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;.    XML Declaration  XML documents may begin by declaring some information about themselves, as in the following example.       &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;       [ edit ]  Characters and escaping   XML documents consist entirely of characters from the Unicode repertoire. Except for a small number of specifically excluded control characters , any character defined by Unicode may appear within the content of an XML document. The selection of characters that may appear within markup is somewhat more limited but still large.  XML includes facilities for identifying the encoding of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly.   [ edit ]  Valid characters   Main article: Valid characters in XML   Unicode code points in the following ranges are valid in XML 1.0 documents:   [ 9 ]      U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0;  U+0020–U+D7FF, U+E000–U+FFFD: this excludes some (not all) non-characters in the BMP (all surrogates, U+FFFE and U+FFFF are forbidden);  U+10000–U+10FFFF: this includes all code points in supplementary planes, including non-characters.   XML 1.1   [ 10 ]   extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001–U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as&amp;#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected.  The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document.   [ edit ]  Encoding detection   The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;. Unicode itself defines encodings that cover the entire repertoire; well-known ones include UTF-8 and UTF-16 .   [ 11 ]   There are many other text encodings that pre-date Unicode, such as ASCII and ISO/IEC 8859 ; their character repertoires in almost every case are subsets of the Unicode character set.  XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.   [ 12 ]   Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser.   [ edit ]  Escaping   XML provides  escape  facilities for including characters which are problematic to include directly. For example:   The characters &quot;&lt;&quot; and &quot;&amp;&quot; are key syntax markers and may never appear in content outside of a CDATA section.   [ 13 ]     Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;é&quot;.  It might not be possible to type the character on the author&apos;s machine.  Some characters have glyphs that cannot be visually distinguished from other characters: examples are  non-breaking-space ( &amp;#xa0; ) &quot; &quot;  compare space ( &amp;#x20; ) &quot; &quot;    Cyrillic Capital Letter A ( &amp;#x410; ) &quot;А&quot;  compare Latin Capital Letter A ( &amp;#x61; ) &quot;A&quot;       There are five predefined entities :    &amp;lt; represents &quot;&lt;&quot;   &amp;gt; represents &quot;&gt;&quot;   &amp;amp; represents &quot;&amp;&quot;   &amp;apos; represents &apos;   &amp;quot; represents &quot;   All permitted Unicode characters may be represented with a  numeric character reference  . Consider the Chinese character &quot;中&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013. A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as &amp;#20013; or &amp;#x4e2d; . Similarly, the string &quot; I&lt;3 Jörg &quot; could be encoded for inclusion in an XML document as &quot; I&amp;lt;3 J&amp;#xF6;rg &quot;.  &quot; &amp;#0; &quot; is not permitted, however, because the null character is one of the control characters excluded from XML, even when using a numeric character reference.   [ 14 ]   An alternative encoding mechanism such as Base64 is needed to represent such characters.   [ edit ]  Comments   Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot; -- &quot; (double-hyphen) is not allowed inside comments. Comments start with &quot;&lt;!--&quot;. The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding.  An example of a valid comment: &quot; &lt;!-- no need to escape&lt;code&gt;&amp;such in comments --&gt; &quot;   [ edit ]  International use         This example contains Chinese text. Without proper rendering support , you may see question marks, boxes, or other symbols instead of Chinese characters .          This example contains Cyrillic text . Without proper rendering support , you may see question marks or boxes , misplaced vowels or missing conjuncts instead of Cyrillic letters.    XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&lt;&quot;). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters:      &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;   &lt;俄语 &gt;  данные &lt;/俄语 &gt;       [ edit ]  Well-formedness and error-handling   Main article: Well-formed document   The XML specification defines an XML document as a text that is well-formed , i.e. it satisfies a list of syntax rules provided in the specification. The list is fairly lengthy; some key points are:   It contains only properly encoded legal Unicode characters.  None of the special syntax characters such as &quot;&lt;&quot; and &quot;&amp;&quot; appear except when performing their markup-delineation roles.  The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping.  The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters !&quot;#$%&amp;&apos;()*+,/;&lt;=&gt;?@[\]^`{|}~, nor a space character, and cannot start with -, ., or a numeric digit.  There is a single &quot;root&quot; element that contains all the other elements.   The definition of an XML document excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as draconian , stands in notable contrast to the behavior of programs that process HTML , which are designed to produce a reasonable result even in the presence of severe markup errors.   [ 15 ]   XML&apos;s policy in this area has been criticized as a violation of Postel&apos;s law (&quot;Be conservative in what you send; be liberal in what you accept&quot;).   [ 16 ]      [ edit ]  Schemas and validation   In addition to being well-formed, an XML document may be valid . This means that it contains a reference to a Document Type Definition (DTD) , and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies.  XML processors are classified as validating or non-validating depending on whether or not they check XML documents for validity. A processor that discovers a validity error must be able to report it, but may continue normal processing.  A DTD is an example of a  schema  or grammar . Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships.   [ edit ]  DTD   Main article: Document Type Definition   The oldest schema language for XML is the Document Type Definition (DTD), inherited from SGML .  DTDs have the following benefits:   DTD support is ubiquitous due to its inclusion in the XML 1.0 standard.  DTDs are terse compared to element-based schema languages and consequently present more information in a single screen.  DTDs allow the declaration of standard public entity sets for publishing characters.  DTDs define a document type rather than the types used by a namespace, thus grouping all constraints for a document in a single collection.   DTDs have the following limitations:   They have no explicit support for newer features of XML, most importantly namespaces .  They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes.  They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual macros ), which make it easier to define complex grammars, but at the expense of clarity.  They use a syntax based on regular expression syntax, inherited from SGML , to describe the schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.   Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining entities , which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes.  DTD technology is still used in many applications because of its ubiquity.   [ edit ]  XML Schema   Main article: XML Schema (W3C)   A newer schema language, described by the W3C as the successor of DTDs, is XML Schema , often referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system and allow for more detailed constraints on an XML document&apos;s logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them.   [ edit ]  RELAX NG   Main article: RELAX NG    RELAX NG was initially specified by OASIS and is now also an ISO/IEC International Standard (as part of DSDL ). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are isomorphic and James Clark &apos;s Trang conversion tool can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins ; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.   [ edit ]  Schematron   Main article: Schematron    Schematron is a language for making assertions about the presence or absence of patterns in an XML document. It typically uses XPath expressions.   [ edit ]  ISO DSDL and other schema languages   The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing .  Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the infoset augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these.   [ edit ]  Related specifications   A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0. It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core.    XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces.   XML Base defines the xml:base attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element.  The XML Information Set or XML infoset describes an abstract data model for XML documents in terms of information items . The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow.  xml:id Version 1.0 asserts that an attribute named xml:id functions as an &quot;ID attribute&quot; in the sense used in a DTD.   XPath defines a syntax named XPath expressions which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document. XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data.   XSLT is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes.   XSL Formatting Objects , or XSL-FO, is a markup language for XML document formatting which is most often used to generate PDFs .   XQuery is an XML-oriented query language strongly rooted in XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for XML databases .   XML Signature defines syntax and processing rules for creating digital signatures on XML content.   XML Encryption defines syntax and processing rules for encrypting XML content.   Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including XInclude , XLink , and XPointer .   [ edit ]  Use on the Internet   XML has come into common use for the interchange of data over the Internet. RFC 3023 gives rules for the construction of Internet Media Types for use when sending XML. It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data are in XML, and nothing about its semantics . The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.   [ 3 ]    RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for SVG .  Further guidelines for the use of XML in a networked context may be found in RFC 3470 , also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language.  XML can also form a crucial part of a databaseless design .   [ edit ]  Programming interfaces   The design goals of XML include, &quot;It shall be easy to write programs which process XML documents.&quot;   [ 6 ]   Despite this, the XML specification contains almost no information about how programmers might go about doing such processing. The XML Infoset specification provides a vocabulary to refer to the constructs within an XML document, but also does not provide any guidance on how to access this information. A variety of APIs for accessing XML have been developed and used, and some have been standardized.  Existing APIs for XML processing tend to fall into these categories:   Stream-oriented APIs accessible from a programming language, for example SAX and StAX .  Tree-traversal APIs accessible from a programming language, for example DOM .   XML data binding , which provides an automated translation between an XML document and programming-language objects.  Declarative transformation languages such as XSLT and XQuery .   Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives. Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions.  XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large XML databases .   [ edit ]  Simple API for XML (SAX)    SAX is a lexical , event-driven interface in which a document is read serially and its contents are reported as callbacks to various methods on a handler object of the user&apos;s design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.   [ edit ]  Pull parsing   Pull parsing   [ 17 ]   treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLReader in PHP and System.Xml.XmlReader in the .NET Framework .  A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace , values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code..   [ edit ]  Document Object Model   The Document Object Model (DOM) is an interface -oriented application programming interface that allows for navigation of the entire document as if it were a tree of node  objects representing the document&apos;s contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings . DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.   [ edit ]  Data binding   Another form of XML processing API is XML data binding , where XML data are made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB) and XML Serialization in .NET.   [ 18 ]      [ edit ]  XML as data type   XML is beginning to appear as a first-class data type in other languages. The ECMAScript for XML (E4X) extension to the ECMAScript /JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.   [ 19 ]   E4X is supported by the Mozilla 2.5+ browsers and Adobe Actionscript , but has not been adopted more universally. Similar notations are used in Microsoft&apos;s LINQ implementation for Microsoft .NET 3.5 and above, and in Scala (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the&lt;[ ]&gt;notation.   [ 20 ]   The Resource Description Framework defines a data type rdf:XMLLiteral to hold wrapped, canonical XML .   [ 21 ]      [ edit ]  History   XML is an application profile of SGML (ISO 8879).   [ 22 ]     The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.   [ 23 ]      [ 24 ]   By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web , and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C&apos;s activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.   [ 25 ]     XML was compiled by a working group of eleven members,   [ 26 ]   supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.   [ 27 ]    James Clark served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty /&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen . Halfway through the project Bray accepted a consulting engagement with Netscape , provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft&apos;s Jean Paoli as a third co-editor.  The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in a short burst of intense work between August and November 1996   [ 28 ]   , when the first Working Draft of an XML specification was published.   [ 29 ]   Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998.   [ edit ]  Sources    XML is a profile of an ISO standard SGML , and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ( processing instructions ), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set ).  Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and HTML , in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP ) metadata accompanied the resource rather than being needed at the declaration of a link. The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0&apos;s naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime .  Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;   [ 30 ]   the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System.   [ edit ]  Versions   There are two current versions of XML. The first ( XML 1.0 ) was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use.  The second ( XML 1.1 ) was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,   [ 31 ]   and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.   [ 32 ]   The main changes are to enable the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.   [ 33 ]     Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the Unicode standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces redundancy . The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the Balinese , Cham , or Phoenician scripts among many others which have been added to Unicode since Unicode 3.2.   [ 32 ]     Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references   [ 34 ]   ). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.  There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for skunkworks ), written by one of the original developers of XML,   [ 35 ]   contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces , XML Base and XML Information Set ( infoset ) into the base standard.  The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name  Fast Infoset  for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).   [ edit ]  Criticism   XML and its extensions have regularly been criticized for verbosity and complexity.   [ 36 ]   Mapping the basic tree model of XML to type systems of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a self-describing language   [ 37 ]   (though the XML specification itself makes no such claim). JSON and YAML are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents.   [ edit ]  See also     List of XML markup languages    Comparison of layout engines (XML)    Binary XML    EBML    WBXML    Category:XML    Category:XML-based standards    Billion laughs (a denial-of-service attack on XML parsers)   XML Protocol    Comparison of data serialization formats     [ edit ]  References       ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 9–11 . http://tools.ietf.org/html/rfc3023#section-3.2   . Retrieved 2010-01-04 .          ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 7–9 . http://tools.ietf.org/html/rfc3023#section-3.1   . Retrieved 2010-01-04 .        ^    a        b     M. Murata, D. Kohn, and C. Lilley (2009-09-24). &quot;Internet Drafts: XML Media Types&quot; . IETF . http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03   . Retrieved 2010-06-10 .          ^    &quot;XML 1.0 Specification&quot; . W3.org . http://www.w3.org/TR/REC-xml   . Retrieved 2010-08-22 .          ^    &quot;W3C DOCUMENT LICENSE&quot;  . http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231  .        ^    a        b      &quot;XML 1.0 Origin and Goals&quot;  . http://www.w3.org/TR/REC-xml/#sec-origin-goals   . Retrieved July 2009 .          ^    &quot;XML Applications and Initiatives&quot;  . http://xml.coverpages.org/xmlApplications.html  .          ^    &quot;Introduction to iWork Programming Guide. Mac OS X Reference Library&quot; . Apple . http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html  .          ^    &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot; . W3.org . http://www.w3.org/TR/2006/REC-xml-20060816/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Characters vs. Bytes&quot;  . http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF  .          ^    &quot;Autodetection of Character Encodings&quot;  . http://www.w3.org/TR/REC-xml/#sec-guessing  .          ^  It is allowed, but not recommended, to use &quot;&lt;&quot; in XML entity values: Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition     ^    &quot;W3C I18N FAQ: HTML, XHTML, XML and Control Codes&quot;  . http://www.w3.org/International/questions/qa-controls  .          ^   http://web.archive.org/web/20110726002036/http://diveintomark.org/archives/2004/01/16/draconianism     ^   http://web.archive.org/web/20110514120305/http://diveintomark.org/archives/2004/01/08/postels-law     ^   Push, Pull, Next! by Bob DuCharme, at XML.com    ^    &quot;XML Serialization in the .NET Framework&quot; . Msdn.microsoft.com . http://msdn.microsoft.com/en-us/library/ms950721.aspx   . Retrieved 2009-07-31 .          ^    &quot;Processing XML with E4X&quot; . Mozilla Developer Center . Mozilla Foundation . https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x  .          ^    &quot;XML Shell: Core Syntax&quot; . xmlsh. 2010-05-13 . http://www.xmlsh.org/CoreSyntax   . Retrieved 2010-08-22 .          ^    &quot;Resource Description Framework (RDF): Concepts and Abstract Syntax&quot; . W3.org . http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral   . Retrieved 2010-08-22 .          ^    ISO/IEC 19757-3 . ISO / IEC . 1 June 2006. p. vi          ^   Bray, Tim (February 2005). &quot;A conversation with Tim Bray: Searching for ways to tame the world&apos;s vast stores of information&quot; . Association for Computing Machinery&apos;s &quot;Queue site&quot; . http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282   . Retrieved April 16, 2006 .          ^   edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley. (1988). &quot;Publishers, multimedia, and interactivity&quot;. Interactive multimedia . Cobb Group. ISBN   1-55615-124-1 .          ^   Eliot Kimber (2006). &quot;XML is 10&quot;  . http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html  .          ^  The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210 .    ^    &quot;Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG&quot; . W3.org . http://www.w3.org/XML/9712-reports.html   . Retrieved 2009-07-31 .          ^  Jon Bosak: The Birth of XML     ^    &quot;Extensible Markup Language (XML)&quot; . W3.org. 1996-11-14 . http://www.w3.org/TR/WD-xml-961114.html   . Retrieved 2009-07-31 .          ^   Jon Bosak, Sun Microsystems (2006-12-07). &quot;Closing Keynote, XML 2006&quot; . 2006.xmlconference.org . http://2006.xmlconference.org/proceedings/162/presentation.html   . Retrieved 2009-07-31 .          ^    &quot;Extensible Markup Language (XML) 1.0 (Third Edition)&quot; . W3.org . http://www.w3.org/TR/2004/REC-xml-20040204   . Retrieved 2010-08-22 .        ^    a        b      &quot;Extensible Markup Language (XML) 1.1 (Second Edition) – Rationale and list of changes for XML 1.1&quot; . W3C . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2012-01-20 .          ^   Harold, Elliotte Rusty (2004).  Effective XML  . Addison-Wesley. pp. 10–19. ISBN   0321150406  . http://www.cafeconleche.org/books/effectivexml/  .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2010-08-22 .          ^  Tim Bray:  Extensible Markup Language - SW (XML-SW) . 2002-02-10    ^  Jeff Atwood (2009): XML: The Angle Bracket Tax     ^  Eric Brown (2003): The Myth of Self-Describing XML      [ edit ]  Further reading    Annex A of ISO 8879:1986 (SGML)   Lawrence A. Cunningham (2005). &quot;Language, Deals and Standards: The Future of XML Contracts&quot;. Washington University Law Review . SSRN   900616 .         Bosak, Jon; Tim Bray (May 1999). &quot;XML and the Second-Generation Web&quot;. Scientific American .      Online at XML and the Second-Generation Web .    Kelly, Sean (February 6, 2006). &quot;Making Mistakes with XML&quot; . Developer.com  . http://www.developer.com/xml/article.php/10929_3583081_1   . Retrieved 2010-10-26 .         Ogbuji, Uche (14 Nov 2006). &quot;Thinking XML: The XML decade&quot; . developerWorks . IBM  . http://www-128.ibm.com/developerworks/library/x-think38.html   . Retrieved 2010-10-26 .         St. Laurent, Simon (February 12, 2003). &quot;Five years later, XML..&quot; . O&apos;Reilly XML Blog . O&apos;Reilly Media  . http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html   . Retrieved 2010-10-26 .          &quot;W3C XML is Ten!&quot; . World Wide Web Consortium . 12 February 2008 . http://www.w3.org/2008/02/xml10-pressrelease   . Retrieved 2010-10-26 .         Flynn, Peter [ed] (5 January 2011). &quot;The XML FAQ&quot; . Cork: Silmaril . http://xml.silmaril.ie/  .          [ edit ]  External links        Wikimedia Commons has media related to:   XML            Wikibooks has more on the topic of    XML               This article&apos;s use of external links may not follow Wikipedia&apos;s policies or guidelines . Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references   (November 2010)        W3C XML homepage    XML 1.0 Specification    Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe    XML, Java and the Future of the Web by Jon Bosak    XML.gov    XML: Ten year anniversary by Elliot Kimber   23 XML fallacies to watch out for by Sean McGrath   XML Injection - Web Application Security Consortium                v      d      e       World Wide Web Consortium          Products and standards         Recommendations        Canonical XML    CDF    CSS    DOM    Geolocation API    HTML    ITS    MathML    OWL    P3P    PLS    RDF    RDF Schema    SISR    SKOS    SMIL    SOAP    SRGS    SSML    SVG    SPARQL    Timed Text    VoiceXML    WSDL    XForms    XHTML    XHTML+RDFa    XInclude    XLink    XML    XML Base    XML Encryption    XML Events    XML Information Set    XML namespace    XML Schema    XML Signature    XPath  1.0 , 2.0    XPointer    XProc    XQuery    XSL    XSL-FO    XSLT  ( elements )             Notes       XAdES    XHTML+SMIL    XUP             Working Drafts       CCXML    CURIE    HTML5    InkML    RIF    SCXML    SMIL Timesheets    sXBL    WICD    XFDL    XFrames    XBL    XHTML+MathML+SVG    XMLHttpRequest             Guidelines       Web Content Accessibility Guidelines             Initiative       Multimodal Interaction Activity    Markup Validation Service    Web Accessibility Initiative             Deprecated       C-HTML    HDML    JSSS    PGML    VML               Organizations      World Wide Web Foundation    SVG Working Group    WebOnt    W3C Device Description Working Group    WHATWG            Software      Agora    Argo    Arena    Amaya    CERN httpd    Libwww    Line Mode Browser            Conference-related      IW3C2    World Wide Web Conference    WWW1            Retrieved from &quot; http://en.wikipedia.org/w/index.php?title=XML&amp;oldid=472314787 &quot;    Categories :   XML    Markup languages    World Wide Web Consortium standards    Technical communication    Bibliography file formats    Computer file formats    Open formats    Data modeling languages    Data serialization formats    Application layer protocols    Presentation layer protocols     Hidden categories:   Articles containing potentially dated statements from 2009    All articles containing potentially dated statements    Wikipedia external links cleanup from November 2010    Wikipedia spam cleanup from November 2010            Personal tools    Log in / create account       Namespaces     Article      Talk        Variants             Views     Read      Edit      View history        Actions            Search                     Navigation     Main page    Contents    Featured content    Current events    Random article    Donate to Wikipedia       Interaction     Help    About Wikipedia    Community portal    Recent changes    Contact Wikipedia       Toolbox     What links here    Related changes    Upload file    Special pages    Permanent link    Cite this page       Print/export     Create a book    Download as PDF    Printable version       Languages     Afrikaans    العربية    Azərbaycanca    বাংলা    Bosanski    Български    Català    Česky    Dansk    Deutsch    Eesti    Ελληνικά    Español    Esperanto    Euskara    فارسی    Français    Gaeilge    Galego    한국어    हिन्दी    Hrvatski    Bahasa Indonesia    Interlingua    Íslenska    Italiano    עברית    ລາວ    Latviešu    Lietuvių    Magyar    Македонски    മലയാളം    Bahasa Melayu    Монгол    Nederlands    日本語    ‪Norsk (bokmål)‬    ‪Norsk (nynorsk)‬    Polski    Português    Română    Русский    Shqip    Simple English    Slovenčina    Slovenščina    کوردی    Српски / Srpski    Srpskohrvatski / Српскохрватски    Suomi    Svenska    தமிழ்    తెలుగు    ไทย    Тоҷикӣ    Türkçe    Türkmençe    Українська    اردو    Tiếng Việt    Žemaitėška    中文         This page was last modified on 20 January 2012 at 20:09.   Text is available under the Creative Commons Attribution-ShareAlike License   ;
additional terms may apply.
See Terms of use for details. Wikipedia&amp;reg;is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization.    Contact us      Privacy policy    About Wikipedia    Disclaimers    Mobile view                          
  </body>


  <title> How Much Food Do I Feed My Dog — Dr. Gregs Dog Dish Diet</title>
  <body>
&apos;      Home    Order Dog Dish Diet Now!    Testimonials    Who is Dr. Greg?    Contact Dr. Greg    PDF Introduction to Crock Pot Cooking Access With Purchase    Dog Dish Diet Videos              How Much Dry Food Should I Feed My Dog?  by Dr Greg on July 24, 2011           In my book, Dog Dish Diet, I go over the calories in dry and canned food and the amount of daily calories a dog should be fed. However, most people use a scoop or their hand to measure dry food. If your dog looks good…no need to change your methods. If your dog is on the chunky side, overweight, or grossly fat you need to measure out the food you feed them. You may also want to consider diluting  the calories in dry food with water or green beans, or feeding something with less carbohydrate calories like canned food,  home cooked food, or a piece of chicken 2-3 nights per week instead of dry food or kibble. Dog Dish Diet teaches us to feed better by learning about ingredients. Some dogs are suffering and dying because they can’t tolerate the ingredients in some commercial foods.( chronic skin problems, ear problems , bladder infections and stones , seizures, diarrhea, diabetes, fatty tumors to name a few)   If your dog has skin, ear, bowel, bladder, or seizure problems consider the Dog Dish Diet and feed your pet to avoid the vet!    Here is a question I received on facebook today:    Doc.. about how much of the chicken stew would a 50lb dog and 80lb dog need daily if the diet was to be changed from dry to this.. of course it would be a gradual change not to upset tummies…    My Answer:          My 80 lb lab eats about 12 oz twice daily. My 10 lb terrier mix eats 6 oz twice daily. My 10 pound bichon/poodle cross eats 6 oz twice daily. You can see that my small dogs need to eat more ounces per pound. In general, dogs need 10-50 calories per pound per day depending on their individual metabolism and energy level.(how much fuel they burn during their normal daily activities)Your  50 pound dog needs anywhere from 500-2500 calories per day depending on activity level. I usually assume 10-20 cal/pound/day for medium to large breeds, 20-30 cal/ pound /day for medium dogs, and 30-40 cal/pound /day for small active dogs. So the stew is 35 calories per ounce, and if 1000 calories needed, about 30 ounces (15 ounces twice daily). The bigger dogs often need less per pound than medium and small dogs unless they move a lot. The 80 pound would get the same or 25 ounces once daily (12 ounces twice daily). Many clients add the stew to moistened dry food as a supplement. One cup 2-3 times a week.      Dry food is usually 45 calories per ounce, canned food is roughly 25 calories per ounce. An 80 pound overweight dog may only need 800 calories per day because they are a slug. This would be about 18 ounces of dry food(2 cups)(or and no hi carb treats!!      Some dogs can’t handle the carbs in dry food or kibble. They gain weight no matter how little dry food they are given. They develop lipomas or fatty tumors. They have dry, flaky, skin. They need more protein, fats, and oils in their diet. Don’t keep feeding the same type of dry, high carbohydrate, low fat food and expect different results. Feed your pet to avoid the vet!!                Leave a Comment      Name *      E-mail *      Website                   Previous post: Temporary Home Remedies for Ear Infections   Next post: Why Does My Dog Eat Poop?                Find more at MindBites, the how-to video marketplace !      Always be among the first to know      Want more articles like the ones to the left?
For your convenience, I’ll send my latest posts directly to your inbox. Sign up now…it’s simple.                    Name:       Email:                             Order your special autographed copy now!           Archives    January 2012    December 2011    November 2011    October 2011    September 2011    August 2011    July 2011    June 2011    May 2011    April 2011    March 2011    February 2011    January 2011    December 2010    November 2010    October 2010    September 2010    August 2010    July 2010    June 2010    May 2010    April 2010    March 2010    February 2010    January 2010    December 2009    November 2009    October 2009    September 2009    August 2009    July 2009    June 2009             Receive your  FREE Copy of Dr. Greg&apos;s 11 Practical Home Remedies for Your Dog              Name  &amp;nbsp;     Email  &amp;nbsp;                  Dog Dish Diet Wins Gold Medal, 2010 Living Now Book Award         Dog Dish Diet Honored with a 2010 Indie Excellence Award         Dog Dish Diet Receives 2010 Next Generation Book Award, Finalist         Dog Dish Diet Wins 2010 San Francisco Book Festival, Honorable Mention                         Tags   California  california veterinarian  canine flu  canine health  canine nutrition  canine vaccines  canine viruses  cat food  cat health  cats  changing do habits  dog bones  Dog Dish Diet  dog food  dog food allergies  dog health  dog nutrition  dog tumors  Dr. Greg  Dr. Greg&apos;s Dog Dish Diet  ear problems in dogs  funny animal story  Gilroy  Gilroy Today  glucosamine  Greg Martinez DVM  healthy dog food  healthy dog snack  healthy eating for cats  healthy eating for dogs  joint pain  neutraceuticals  Omega 3  OPC  overweight cats  parrot  parvo  people food for dogs  pets  pet safety  poisons  radio broadcast  tick-borne diseases  ticks  veterinarian           Dog Dish Diet on Facebook          © 2011 Greg Martinez, DVM   WordPress Admin         
  </body>


  <title> XML - Wikipedia, the free encyclopedia</title>
  <body>
            XML   From Wikipedia, the free encyclopedia    Jump to: navigation , search        XML           Filename extension    .xml      Internet media type    application/xml ,   [ 1 ]     text/xml    [ 2 ]   (deprecated in an expired draft)   [ 3 ]        Uniform Type Identifier   public.xml    UTI conforms to  public.text    Developed by   World Wide Web Consortium     Type of format   Markup language     Extended from   SGML     Extended to   Numerous , including:  XHTML , RSS , Atom , KML      Standard(s)    1.0 (Fifth Edition) November 26, 2008 ; 3 years ago   ( 2008-11-26 )   1.1 (Second Edition) August 16, 2006 ; 5 years ago   ( 2006-08-16 )      Open format ?  Yes      Extensible Markup Language (XML)    Current Status  Published    Year Started  1996    Editors  Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan    Related Standards   XML Schema     Domain   Data Serialization     Abbreviation  XML    Website   XML 1.0         Extensible Markup Language ( XML ) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable . It is defined in the XML 1.0 Specification   [ 4 ]   produced by the W3C , and several other related specifications, all gratis  open standards .   [ 5 ]     The design goals of XML emphasize simplicity, generality, and usability over the Internet .   [ 6 ]   It is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary data structures , for example in web services .  Many application programming interfaces (APIs) have been developed for software developers to use to process XML data, and several schema systems exist to aid in the definition of XML-based languages.  As of 2009  [update]  , hundreds of XML-based languages have been developed,   [ 7 ]   including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for many office-productivity tools, including Microsoft Office ( Office Open XML ), OpenOffice.org ( OpenDocument ), and Apple &apos;s iWork .   [ 8 ]   XML has also been employed as the base language for communication protocols , such as XMPP .      Contents      1  Key terminology      2  Characters and escaping      2.1  Valid characters      2.2  Encoding detection      2.3  Escaping      2.4  Comments      2.5  International use        3  Well-formedness and error-handling      4  Schemas and validation      4.1  DTD      4.2  XML Schema      4.3  RELAX NG      4.4  Schematron      4.5  ISO DSDL and other schema languages        5  Related specifications      6  Use on the Internet      7  Programming interfaces      7.1  Simple API for XML (SAX)      7.2  Pull parsing      7.3  Document Object Model      7.4  Data binding      7.5  XML as data type        8  History      8.1  Sources      8.2  Versions        9  Criticism      10  See also      11  References      12  Further reading      13  External links         [ edit ]  Key terminology   The material in this section is based on the XML Specification. This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use.   (Unicode) Character  By definition, an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document.    Processor and Application  The processor analyzes the markup and passes structured information to an application . The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an XML parser .    Markup and Content  The characters which make up an XML document are divided into markup and content . Markup and content may be distinguished by the application of simple syntactic rules. All strings which constitute markup either begin with the character &quot;&lt;&quot; and end with a &quot;&gt;&quot;, or begin with the character &quot;&amp;&quot; and end with a &quot;;&quot;. Strings of characters which are not markup are content.    Tag  A markup construct that begins with &quot;&lt;&quot; and ends with &quot;&gt;&quot;. Tags come in three flavors: start-tags , for example &lt;section&gt; , end-tags , for example &lt;/section&gt; , and empty-element tags , for example &lt;line-break /&gt; .    Element  A logical document component either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start- and end-tags, if any, are the element&apos;s content , and may contain markup, including other elements, which are called child elements . An example of an element is &lt;Greeting&gt;Hello, world.&lt;/Greeting&gt; (see hello world ). Another is &lt;line-break /&gt; .    Attribute  A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag. In the example (below) the element img has two attributes, src and alt : &lt;img src=&quot;madonna.jpg&quot; alt=&apos;Foligno Madonna, by Raphael&apos; /&gt; . Another example would be &lt;step number=&quot;3&quot;&gt;Connect A to B.&lt;/step&gt; where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;.    XML Declaration  XML documents may begin by declaring some information about themselves, as in the following example.       &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;       [ edit ]  Characters and escaping   XML documents consist entirely of characters from the Unicode repertoire. Except for a small number of specifically excluded control characters , any character defined by Unicode may appear within the content of an XML document. The selection of characters that may appear within markup is somewhat more limited but still large.  XML includes facilities for identifying the encoding of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly.   [ edit ]  Valid characters   Main article: Valid characters in XML   Unicode code points in the following ranges are valid in XML 1.0 documents:   [ 9 ]      U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0;  U+0020–U+D7FF, U+E000–U+FFFD: this excludes some (not all) non-characters in the BMP (all surrogates, U+FFFE and U+FFFF are forbidden);  U+10000–U+10FFFF: this includes all code points in supplementary planes, including non-characters.   XML 1.1   [ 10 ]   extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001–U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as&amp;#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected.  The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document.   [ edit ]  Encoding detection   The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;. Unicode itself defines encodings that cover the entire repertoire; well-known ones include UTF-8 and UTF-16 .   [ 11 ]   There are many other text encodings that pre-date Unicode, such as ASCII and ISO/IEC 8859 ; their character repertoires in almost every case are subsets of the Unicode character set.  XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.   [ 12 ]   Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser.   [ edit ]  Escaping   XML provides  escape  facilities for including characters which are problematic to include directly. For example:   The characters &quot;&lt;&quot; and &quot;&amp;&quot; are key syntax markers and may never appear in content outside of a CDATA section.   [ 13 ]     Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;é&quot;.  It might not be possible to type the character on the author&apos;s machine.  Some characters have glyphs that cannot be visually distinguished from other characters: examples are  non-breaking-space ( &amp;#xa0; ) &quot; &quot;  compare space ( &amp;#x20; ) &quot; &quot;    Cyrillic Capital Letter A ( &amp;#x410; ) &quot;А&quot;  compare Latin Capital Letter A ( &amp;#x61; ) &quot;A&quot;       There are five predefined entities :    &amp;lt; represents &quot;&lt;&quot;   &amp;gt; represents &quot;&gt;&quot;   &amp;amp; represents &quot;&amp;&quot;   &amp;apos; represents &apos;   &amp;quot; represents &quot;   All permitted Unicode characters may be represented with a  numeric character reference  . Consider the Chinese character &quot;中&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013. A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as &amp;#20013; or &amp;#x4e2d; . Similarly, the string &quot; I&lt;3 Jörg &quot; could be encoded for inclusion in an XML document as &quot; I&amp;lt;3 J&amp;#xF6;rg &quot;.  &quot; &amp;#0; &quot; is not permitted, however, because the null character is one of the control characters excluded from XML, even when using a numeric character reference.   [ 14 ]   An alternative encoding mechanism such as Base64 is needed to represent such characters.   [ edit ]  Comments   Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot; -- &quot; (double-hyphen) is not allowed inside comments. Comments start with &quot;&lt;!--&quot;. The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding.  An example of a valid comment: &quot; &lt;!-- no need to escape&lt;code&gt;&amp;such in comments --&gt; &quot;   [ edit ]  International use         This example contains Chinese text. Without proper rendering support , you may see question marks, boxes, or other symbols instead of Chinese characters .          This example contains Cyrillic text . Without proper rendering support , you may see question marks or boxes , misplaced vowels or missing conjuncts instead of Cyrillic letters.    XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&lt;&quot;). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters:      &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;   &lt;俄语 &gt;  данные &lt;/俄语 &gt;       [ edit ]  Well-formedness and error-handling   Main article: Well-formed document   The XML specification defines an XML document as a text that is well-formed , i.e. it satisfies a list of syntax rules provided in the specification. The list is fairly lengthy; some key points are:   It contains only properly encoded legal Unicode characters.  None of the special syntax characters such as &quot;&lt;&quot; and &quot;&amp;&quot; appear except when performing their markup-delineation roles.  The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping.  The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters !&quot;#$%&amp;&apos;()*+,/;&lt;=&gt;?@[\]^`{|}~, nor a space character, and cannot start with -, ., or a numeric digit.  There is a single &quot;root&quot; element that contains all the other elements.   The definition of an XML document excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as draconian , stands in notable contrast to the behavior of programs that process HTML , which are designed to produce a reasonable result even in the presence of severe markup errors.   [ 15 ]   XML&apos;s policy in this area has been criticized as a violation of Postel&apos;s law (&quot;Be conservative in what you send; be liberal in what you accept&quot;).   [ 16 ]      [ edit ]  Schemas and validation   In addition to being well-formed, an XML document may be valid . This means that it contains a reference to a Document Type Definition (DTD) , and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies.  XML processors are classified as validating or non-validating depending on whether or not they check XML documents for validity. A processor that discovers a validity error must be able to report it, but may continue normal processing.  A DTD is an example of a  schema  or grammar . Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships.   [ edit ]  DTD   Main article: Document Type Definition   The oldest schema language for XML is the Document Type Definition (DTD), inherited from SGML .  DTDs have the following benefits:   DTD support is ubiquitous due to its inclusion in the XML 1.0 standard.  DTDs are terse compared to element-based schema languages and consequently present more information in a single screen.  DTDs allow the declaration of standard public entity sets for publishing characters.  DTDs define a document type rather than the types used by a namespace, thus grouping all constraints for a document in a single collection.   DTDs have the following limitations:   They have no explicit support for newer features of XML, most importantly namespaces .  They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes.  They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual macros ), which make it easier to define complex grammars, but at the expense of clarity.  They use a syntax based on regular expression syntax, inherited from SGML , to describe the schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.   Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining entities , which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes.  DTD technology is still used in many applications because of its ubiquity.   [ edit ]  XML Schema   Main article: XML Schema (W3C)   A newer schema language, described by the W3C as the successor of DTDs, is XML Schema , often referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system and allow for more detailed constraints on an XML document&apos;s logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them.   [ edit ]  RELAX NG   Main article: RELAX NG    RELAX NG was initially specified by OASIS and is now also an ISO/IEC International Standard (as part of DSDL ). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are isomorphic and James Clark &apos;s Trang conversion tool can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins ; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.   [ edit ]  Schematron   Main article: Schematron    Schematron is a language for making assertions about the presence or absence of patterns in an XML document. It typically uses XPath expressions.   [ edit ]  ISO DSDL and other schema languages   The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing .  Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the infoset augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these.   [ edit ]  Related specifications   A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0. It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core.    XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces.   XML Base defines the xml:base attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element.  The XML Information Set or XML infoset describes an abstract data model for XML documents in terms of information items . The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow.  xml:id Version 1.0 asserts that an attribute named xml:id functions as an &quot;ID attribute&quot; in the sense used in a DTD.   XPath defines a syntax named XPath expressions which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document. XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data.   XSLT is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes.   XSL Formatting Objects , or XSL-FO, is a markup language for XML document formatting which is most often used to generate PDFs .   XQuery is an XML-oriented query language strongly rooted in XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for XML databases .   XML Signature defines syntax and processing rules for creating digital signatures on XML content.   XML Encryption defines syntax and processing rules for encrypting XML content.   Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including XInclude , XLink , and XPointer .   [ edit ]  Use on the Internet   XML has come into common use for the interchange of data over the Internet. RFC 3023 gives rules for the construction of Internet Media Types for use when sending XML. It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data are in XML, and nothing about its semantics . The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.   [ 3 ]    RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for SVG .  Further guidelines for the use of XML in a networked context may be found in RFC 3470 , also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language.  XML can also form a crucial part of a databaseless design .   [ edit ]  Programming interfaces   The design goals of XML include, &quot;It shall be easy to write programs which process XML documents.&quot;   [ 6 ]   Despite this, the XML specification contains almost no information about how programmers might go about doing such processing. The XML Infoset specification provides a vocabulary to refer to the constructs within an XML document, but also does not provide any guidance on how to access this information. A variety of APIs for accessing XML have been developed and used, and some have been standardized.  Existing APIs for XML processing tend to fall into these categories:   Stream-oriented APIs accessible from a programming language, for example SAX and StAX .  Tree-traversal APIs accessible from a programming language, for example DOM .   XML data binding , which provides an automated translation between an XML document and programming-language objects.  Declarative transformation languages such as XSLT and XQuery .   Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives. Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions.  XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large XML databases .   [ edit ]  Simple API for XML (SAX)    SAX is a lexical , event-driven interface in which a document is read serially and its contents are reported as callbacks to various methods on a handler object of the user&apos;s design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.   [ edit ]  Pull parsing   Pull parsing   [ 17 ]   treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLReader in PHP and System.Xml.XmlReader in the .NET Framework .  A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace , values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code..   [ edit ]  Document Object Model   The Document Object Model (DOM) is an interface -oriented application programming interface that allows for navigation of the entire document as if it were a tree of node  objects representing the document&apos;s contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings . DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.   [ edit ]  Data binding   Another form of XML processing API is XML data binding , where XML data are made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB) and XML Serialization in .NET.   [ 18 ]      [ edit ]  XML as data type   XML is beginning to appear as a first-class data type in other languages. The ECMAScript for XML (E4X) extension to the ECMAScript /JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.   [ 19 ]   E4X is supported by the Mozilla 2.5+ browsers and Adobe Actionscript , but has not been adopted more universally. Similar notations are used in Microsoft&apos;s LINQ implementation for Microsoft .NET 3.5 and above, and in Scala (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the&lt;[ ]&gt;notation.   [ 20 ]   The Resource Description Framework defines a data type rdf:XMLLiteral to hold wrapped, canonical XML .   [ 21 ]      [ edit ]  History   XML is an application profile of SGML (ISO 8879).   [ 22 ]     The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.   [ 23 ]      [ 24 ]   By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web , and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C&apos;s activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.   [ 25 ]     XML was compiled by a working group of eleven members,   [ 26 ]   supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.   [ 27 ]    James Clark served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty /&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen . Halfway through the project Bray accepted a consulting engagement with Netscape , provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft&apos;s Jean Paoli as a third co-editor.  The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in a short burst of intense work between August and November 1996   [ 28 ]   , when the first Working Draft of an XML specification was published.   [ 29 ]   Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998.   [ edit ]  Sources    XML is a profile of an ISO standard SGML , and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ( processing instructions ), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set ).  Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and HTML , in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP ) metadata accompanied the resource rather than being needed at the declaration of a link. The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0&apos;s naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime .  Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;   [ 30 ]   the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System.   [ edit ]  Versions   There are two current versions of XML. The first ( XML 1.0 ) was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use.  The second ( XML 1.1 ) was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,   [ 31 ]   and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.   [ 32 ]   The main changes are to enable the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.   [ 33 ]     Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the Unicode standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces redundancy . The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the Balinese , Cham , or Phoenician scripts among many others which have been added to Unicode since Unicode 3.2.   [ 32 ]     Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references   [ 34 ]   ). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.  There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for skunkworks ), written by one of the original developers of XML,   [ 35 ]   contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces , XML Base and XML Information Set ( infoset ) into the base standard.  The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name  Fast Infoset  for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).   [ edit ]  Criticism   XML and its extensions have regularly been criticized for verbosity and complexity.   [ 36 ]   Mapping the basic tree model of XML to type systems of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a self-describing language   [ 37 ]   (though the XML specification itself makes no such claim). JSON and YAML are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents.   [ edit ]  See also     List of XML markup languages    Comparison of layout engines (XML)    Binary XML    EBML    WBXML    Category:XML    Category:XML-based standards    Billion laughs (a denial-of-service attack on XML parsers)   XML Protocol    Comparison of data serialization formats     [ edit ]  References       ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 9–11 . http://tools.ietf.org/html/rfc3023#section-3.2   . Retrieved 2010-01-04 .          ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 7–9 . http://tools.ietf.org/html/rfc3023#section-3.1   . Retrieved 2010-01-04 .        ^    a        b     M. Murata, D. Kohn, and C. Lilley (2009-09-24). &quot;Internet Drafts: XML Media Types&quot; . IETF . http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03   . Retrieved 2010-06-10 .          ^    &quot;XML 1.0 Specification&quot; . W3.org . http://www.w3.org/TR/REC-xml   . Retrieved 2010-08-22 .          ^    &quot;W3C DOCUMENT LICENSE&quot;  . http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231  .        ^    a        b      &quot;XML 1.0 Origin and Goals&quot;  . http://www.w3.org/TR/REC-xml/#sec-origin-goals   . Retrieved July 2009 .          ^    &quot;XML Applications and Initiatives&quot;  . http://xml.coverpages.org/xmlApplications.html  .          ^    &quot;Introduction to iWork Programming Guide. Mac OS X Reference Library&quot; . Apple . http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html  .          ^    &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot; . W3.org . http://www.w3.org/TR/2006/REC-xml-20060816/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Characters vs. Bytes&quot;  . http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF  .          ^    &quot;Autodetection of Character Encodings&quot;  . http://www.w3.org/TR/REC-xml/#sec-guessing  .          ^  It is allowed, but not recommended, to use &quot;&lt;&quot; in XML entity values: Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition     ^    &quot;W3C I18N FAQ: HTML, XHTML, XML and Control Codes&quot;  . http://www.w3.org/International/questions/qa-controls  .          ^   http://web.archive.org/web/20110726002036/http://diveintomark.org/archives/2004/01/16/draconianism     ^   http://web.archive.org/web/20110514120305/http://diveintomark.org/archives/2004/01/08/postels-law     ^   Push, Pull, Next! by Bob DuCharme, at XML.com    ^    &quot;XML Serialization in the .NET Framework&quot; . Msdn.microsoft.com . http://msdn.microsoft.com/en-us/library/ms950721.aspx   . Retrieved 2009-07-31 .          ^    &quot;Processing XML with E4X&quot; . Mozilla Developer Center . Mozilla Foundation . https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x  .          ^    &quot;XML Shell: Core Syntax&quot; . xmlsh. 2010-05-13 . http://www.xmlsh.org/CoreSyntax   . Retrieved 2010-08-22 .          ^    &quot;Resource Description Framework (RDF): Concepts and Abstract Syntax&quot; . W3.org . http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral   . Retrieved 2010-08-22 .          ^    ISO/IEC 19757-3 . ISO / IEC . 1 June 2006. p. vi          ^   Bray, Tim (February 2005). &quot;A conversation with Tim Bray: Searching for ways to tame the world&apos;s vast stores of information&quot; . Association for Computing Machinery&apos;s &quot;Queue site&quot; . http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282   . Retrieved April 16, 2006 .          ^   edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley. (1988). &quot;Publishers, multimedia, and interactivity&quot;. Interactive multimedia . Cobb Group. ISBN   1-55615-124-1 .          ^   Eliot Kimber (2006). &quot;XML is 10&quot;  . http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html  .          ^  The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210 .    ^    &quot;Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG&quot; . W3.org . http://www.w3.org/XML/9712-reports.html   . Retrieved 2009-07-31 .          ^  Jon Bosak: The Birth of XML     ^    &quot;Extensible Markup Language (XML)&quot; . W3.org. 1996-11-14 . http://www.w3.org/TR/WD-xml-961114.html   . Retrieved 2009-07-31 .          ^   Jon Bosak, Sun Microsystems (2006-12-07). &quot;Closing Keynote, XML 2006&quot; . 2006.xmlconference.org . http://2006.xmlconference.org/proceedings/162/presentation.html   . Retrieved 2009-07-31 .          ^    &quot;Extensible Markup Language (XML) 1.0 (Third Edition)&quot; . W3.org . http://www.w3.org/TR/2004/REC-xml-20040204   . Retrieved 2010-08-22 .        ^    a        b      &quot;Extensible Markup Language (XML) 1.1 (Second Edition) – Rationale and list of changes for XML 1.1&quot; . W3C . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2012-01-20 .          ^   Harold, Elliotte Rusty (2004).  Effective XML  . Addison-Wesley. pp. 10–19. ISBN   0321150406  . http://www.cafeconleche.org/books/effectivexml/  .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2010-08-22 .          ^  Tim Bray:  Extensible Markup Language - SW (XML-SW) . 2002-02-10    ^  Jeff Atwood (2009): XML: The Angle Bracket Tax     ^  Eric Brown (2003): The Myth of Self-Describing XML      [ edit ]  Further reading    Annex A of ISO 8879:1986 (SGML)   Lawrence A. Cunningham (2005). &quot;Language, Deals and Standards: The Future of XML Contracts&quot;. Washington University Law Review . SSRN   900616 .         Bosak, Jon; Tim Bray (May 1999). &quot;XML and the Second-Generation Web&quot;. Scientific American .      Online at XML and the Second-Generation Web .    Kelly, Sean (February 6, 2006). &quot;Making Mistakes with XML&quot; . Developer.com  . http://www.developer.com/xml/article.php/10929_3583081_1   . Retrieved 2010-10-26 .         Ogbuji, Uche (14 Nov 2006). &quot;Thinking XML: The XML decade&quot; . developerWorks . IBM  . http://www-128.ibm.com/developerworks/library/x-think38.html   . Retrieved 2010-10-26 .         St. Laurent, Simon (February 12, 2003). &quot;Five years later, XML..&quot; . O&apos;Reilly XML Blog . O&apos;Reilly Media  . http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html   . Retrieved 2010-10-26 .          &quot;W3C XML is Ten!&quot; . World Wide Web Consortium . 12 February 2008 . http://www.w3.org/2008/02/xml10-pressrelease   . Retrieved 2010-10-26 .         Flynn, Peter [ed] (5 January 2011). &quot;The XML FAQ&quot; . Cork: Silmaril . http://xml.silmaril.ie/  .          [ edit ]  External links        Wikimedia Commons has media related to:   XML            Wikibooks has more on the topic of    XML               This article&apos;s use of external links may not follow Wikipedia&apos;s policies or guidelines . Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references   (November 2010)        W3C XML homepage    XML 1.0 Specification    Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe    XML, Java and the Future of the Web by Jon Bosak    XML.gov    XML: Ten year anniversary by Elliot Kimber   23 XML fallacies to watch out for by Sean McGrath   XML Injection - Web Application Security Consortium                v      d      e       World Wide Web Consortium          Products and standards         Recommendations        Canonical XML    CDF    CSS    DOM    Geolocation API    HTML    ITS    MathML    OWL    P3P    PLS    RDF    RDF Schema    SISR    SKOS    SMIL    SOAP    SRGS    SSML    SVG    SPARQL    Timed Text    VoiceXML    WSDL    XForms    XHTML    XHTML+RDFa    XInclude    XLink    XML    XML Base    XML Encryption    XML Events    XML Information Set    XML namespace    XML Schema    XML Signature    XPath  1.0 , 2.0    XPointer    XProc    XQuery    XSL    XSL-FO    XSLT  ( elements )             Notes       XAdES    XHTML+SMIL    XUP             Working Drafts       CCXML    CURIE    HTML5    InkML    RIF    SCXML    SMIL Timesheets    sXBL    WICD    XFDL    XFrames    XBL    XHTML+MathML+SVG    XMLHttpRequest             Guidelines       Web Content Accessibility Guidelines             Initiative       Multimodal Interaction Activity    Markup Validation Service    Web Accessibility Initiative             Deprecated       C-HTML    HDML    JSSS    PGML    VML               Organizations      World Wide Web Foundation    SVG Working Group    WebOnt    W3C Device Description Working Group    WHATWG            Software      Agora    Argo    Arena    Amaya    CERN httpd    Libwww    Line Mode Browser            Conference-related      IW3C2    World Wide Web Conference    WWW1            Retrieved from &quot; http://en.wikipedia.org/w/index.php?title=XML&amp;oldid=472314787 &quot;    Categories :   XML    Markup languages    World Wide Web Consortium standards    Technical communication    Bibliography file formats    Computer file formats    Open formats    Data modeling languages    Data serialization formats    Application layer protocols    Presentation layer protocols     Hidden categories:   Articles containing potentially dated statements from 2009    All articles containing potentially dated statements    Wikipedia external links cleanup from November 2010    Wikipedia spam cleanup from November 2010            Personal tools    Log in / create account       Namespaces     Article      Talk        Variants             Views     Read      Edit      View history        Actions            Search                     Navigation     Main page    Contents    Featured content    Current events    Random article    Donate to Wikipedia       Interaction     Help    About Wikipedia    Community portal    Recent changes    Contact Wikipedia       Toolbox     What links here    Related changes    Upload file    Special pages    Permanent link    Cite this page       Print/export     Create a book    Download as PDF    Printable version       Languages     Afrikaans    العربية    Azərbaycanca    বাংলা    Bosanski    Български    Català    Česky    Dansk    Deutsch    Eesti    Ελληνικά    Español    Esperanto    Euskara    فارسی    Français    Gaeilge    Galego    한국어    हिन्दी    Hrvatski    Bahasa Indonesia    Interlingua    Íslenska    Italiano    עברית    ລາວ    Latviešu    Lietuvių    Magyar    Македонски    മലയാളം    Bahasa Melayu    Монгол    Nederlands    日本語    ‪Norsk (bokmål)‬    ‪Norsk (nynorsk)‬    Polski    Português    Română    Русский    Shqip    Simple English    Slovenčina    Slovenščina    کوردی    Српски / Srpski    Srpskohrvatski / Српскохрватски    Suomi    Svenska    தமிழ்    తెలుగు    ไทย    Тоҷикӣ    Türkçe    Türkmençe    Українська    اردو    Tiếng Việt    Žemaitėška    中文         This page was last modified on 20 January 2012 at 20:09.   Text is available under the Creative Commons Attribution-ShareAlike License   ;
additional terms may apply.
See Terms of use for details. Wikipedia&amp;reg;is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization.    Contact us      Privacy policy    About Wikipedia    Disclaimers    Mobile view                          
  </body>


  <title> How Much Food Do I Feed My Dog — Dr. Gregs Dog Dish Diet</title>
  <body>
&apos;      Home    Order Dog Dish Diet Now!    Testimonials    Who is Dr. Greg?    Contact Dr. Greg    PDF Introduction to Crock Pot Cooking Access With Purchase    Dog Dish Diet Videos              How Much Dry Food Should I Feed My Dog?  by Dr Greg on July 24, 2011           In my book, Dog Dish Diet, I go over the calories in dry and canned food and the amount of daily calories a dog should be fed. However, most people use a scoop or their hand to measure dry food. If your dog looks good…no need to change your methods. If your dog is on the chunky side, overweight, or grossly fat you need to measure out the food you feed them. You may also want to consider diluting  the calories in dry food with water or green beans, or feeding something with less carbohydrate calories like canned food,  home cooked food, or a piece of chicken 2-3 nights per week instead of dry food or kibble. Dog Dish Diet teaches us to feed better by learning about ingredients. Some dogs are suffering and dying because they can’t tolerate the ingredients in some commercial foods.( chronic skin problems, ear problems , bladder infections and stones , seizures, diarrhea, diabetes, fatty tumors to name a few)   If your dog has skin, ear, bowel, bladder, or seizure problems consider the Dog Dish Diet and feed your pet to avoid the vet!    Here is a question I received on facebook today:    Doc.. about how much of the chicken stew would a 50lb dog and 80lb dog need daily if the diet was to be changed from dry to this.. of course it would be a gradual change not to upset tummies…    My Answer:          My 80 lb lab eats about 12 oz twice daily. My 10 lb terrier mix eats 6 oz twice daily. My 10 pound bichon/poodle cross eats 6 oz twice daily. You can see that my small dogs need to eat more ounces per pound. In general, dogs need 10-50 calories per pound per day depending on their individual metabolism and energy level.(how much fuel they burn during their normal daily activities)Your  50 pound dog needs anywhere from 500-2500 calories per day depending on activity level. I usually assume 10-20 cal/pound/day for medium to large breeds, 20-30 cal/ pound /day for medium dogs, and 30-40 cal/pound /day for small active dogs. So the stew is 35 calories per ounce, and if 1000 calories needed, about 30 ounces (15 ounces twice daily). The bigger dogs often need less per pound than medium and small dogs unless they move a lot. The 80 pound would get the same or 25 ounces once daily (12 ounces twice daily). Many clients add the stew to moistened dry food as a supplement. One cup 2-3 times a week.      Dry food is usually 45 calories per ounce, canned food is roughly 25 calories per ounce. An 80 pound overweight dog may only need 800 calories per day because they are a slug. This would be about 18 ounces of dry food(2 cups)(or and no hi carb treats!!      Some dogs can’t handle the carbs in dry food or kibble. They gain weight no matter how little dry food they are given. They develop lipomas or fatty tumors. They have dry, flaky, skin. They need more protein, fats, and oils in their diet. Don’t keep feeding the same type of dry, high carbohydrate, low fat food and expect different results. Feed your pet to avoid the vet!!                Leave a Comment      Name *      E-mail *      Website                   Previous post: Temporary Home Remedies for Ear Infections   Next post: Why Does My Dog Eat Poop?                Find more at MindBites, the how-to video marketplace !      Always be among the first to know      Want more articles like the ones to the left?
For your convenience, I’ll send my latest posts directly to your inbox. Sign up now…it’s simple.                    Name:       Email:                             Order your special autographed copy now!           Archives    January 2012    December 2011    November 2011    October 2011    September 2011    August 2011    July 2011    June 2011    May 2011    April 2011    March 2011    February 2011    January 2011    December 2010    November 2010    October 2010    September 2010    August 2010    July 2010    June 2010    May 2010    April 2010    March 2010    February 2010    January 2010    December 2009    November 2009    October 2009    September 2009    August 2009    July 2009    June 2009             Receive your  FREE Copy of Dr. Greg&apos;s 11 Practical Home Remedies for Your Dog              Name        Email                     Dog Dish Diet Wins Gold Medal, 2010 Living Now Book Award         Dog Dish Diet Honored with a 2010 Indie Excellence Award         Dog Dish Diet Receives 2010 Next Generation Book Award, Finalist         Dog Dish Diet Wins 2010 San Francisco Book Festival, Honorable Mention                         Tags   California  california veterinarian  canine flu  canine health  canine nutrition  canine vaccines  canine viruses  cat food  cat health  cats  changing do habits  dog bones  Dog Dish Diet  dog food  dog food allergies  dog health  dog nutrition  dog tumors  Dr. Greg  Dr. Greg&apos;s Dog Dish Diet  ear problems in dogs  funny animal story  Gilroy  Gilroy Today  glucosamine  Greg Martinez DVM  healthy dog food  healthy dog snack  healthy eating for cats  healthy eating for dogs  joint pain  neutraceuticals  Omega 3  OPC  overweight cats  parrot  parvo  people food for dogs  pets  pet safety  poisons  radio broadcast  tick-borne diseases  ticks  veterinarian           Dog Dish Diet on Facebook          © 2011 Greg Martinez, DVM   WordPress Admin         
  </body>


  <title> XML - Wikipedia, the free encyclopedia</title>
  <body>
            XML   From Wikipedia, the free encyclopedia    Jump to: navigation , search        XML           Filename extension    .xml      Internet media type    application/xml ,   [ 1 ]     text/xml    [ 2 ]   (deprecated in an expired draft)   [ 3 ]        Uniform Type Identifier   public.xml    UTI conforms to  public.text    Developed by   World Wide Web Consortium     Type of format   Markup language     Extended from   SGML     Extended to   Numerous , including:  XHTML , RSS , Atom , KML      Standard(s)    1.0 (Fifth Edition) November 26, 2008 ; 3 years ago   ( 2008-11-26 )   1.1 (Second Edition) August 16, 2006 ; 5 years ago   ( 2006-08-16 )      Open format ?  Yes      Extensible Markup Language (XML)    Current Status  Published    Year Started  1996    Editors  Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan    Related Standards   XML Schema     Domain   Data Serialization     Abbreviation  XML    Website   XML 1.0         Extensible Markup Language ( XML ) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable . It is defined in the XML 1.0 Specification   [ 4 ]   produced by the W3C , and several other related specifications, all gratis  open standards .   [ 5 ]     The design goals of XML emphasize simplicity, generality, and usability over the Internet .   [ 6 ]   It is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary data structures , for example in web services .  Many application programming interfaces (APIs) have been developed for software developers to use to process XML data, and several schema systems exist to aid in the definition of XML-based languages.  As of 2009  [update]  , hundreds of XML-based languages have been developed,   [ 7 ]   including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for many office-productivity tools, including Microsoft Office ( Office Open XML ), OpenOffice.org ( OpenDocument ), and Apple &apos;s iWork .   [ 8 ]   XML has also been employed as the base language for communication protocols , such as XMPP .      Contents      1  Key terminology      2  Characters and escaping      2.1  Valid characters      2.2  Encoding detection      2.3  Escaping      2.4  Comments      2.5  International use        3  Well-formedness and error-handling      4  Schemas and validation      4.1  DTD      4.2  XML Schema      4.3  RELAX NG      4.4  Schematron      4.5  ISO DSDL and other schema languages        5  Related specifications      6  Use on the Internet      7  Programming interfaces      7.1  Simple API for XML (SAX)      7.2  Pull parsing      7.3  Document Object Model      7.4  Data binding      7.5  XML as data type        8  History      8.1  Sources      8.2  Versions        9  Criticism      10  See also      11  References      12  Further reading      13  External links         [ edit ]  Key terminology   The material in this section is based on the XML Specification. This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use.   (Unicode) Character  By definition, an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document.    Processor and Application  The processor analyzes the markup and passes structured information to an application . The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an XML parser .    Markup and Content  The characters which make up an XML document are divided into markup and content . Markup and content may be distinguished by the application of simple syntactic rules. All strings which constitute markup either begin with the character &quot;&lt;&quot; and end with a &quot;&gt;&quot;, or begin with the character &quot;&amp;&quot; and end with a &quot;;&quot;. Strings of characters which are not markup are content.    Tag  A markup construct that begins with &quot;&lt;&quot; and ends with &quot;&gt;&quot;. Tags come in three flavors: start-tags , for example &lt;section&gt; , end-tags , for example &lt;/section&gt; , and empty-element tags , for example &lt;line-break /&gt; .    Element  A logical document component either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start- and end-tags, if any, are the element&apos;s content , and may contain markup, including other elements, which are called child elements . An example of an element is &lt;Greeting&gt;Hello, world.&lt;/Greeting&gt; (see hello world ). Another is &lt;line-break /&gt; .    Attribute  A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag. In the example (below) the element img has two attributes, src and alt : &lt;img src=&quot;madonna.jpg&quot; alt=&apos;Foligno Madonna, by Raphael&apos; /&gt; . Another example would be &lt;step number=&quot;3&quot;&gt;Connect A to B.&lt;/step&gt; where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;.    XML Declaration  XML documents may begin by declaring some information about themselves, as in the following example.       &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;       [ edit ]  Characters and escaping   XML documents consist entirely of characters from the Unicode repertoire. Except for a small number of specifically excluded control characters , any character defined by Unicode may appear within the content of an XML document. The selection of characters that may appear within markup is somewhat more limited but still large.  XML includes facilities for identifying the encoding of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly.   [ edit ]  Valid characters   Main article: Valid characters in XML   Unicode code points in the following ranges are valid in XML 1.0 documents:   [ 9 ]      U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0;  U+0020–U+D7FF, U+E000–U+FFFD: this excludes some (not all) non-characters in the BMP (all surrogates, U+FFFE and U+FFFF are forbidden);  U+10000–U+10FFFF: this includes all code points in supplementary planes, including non-characters.   XML 1.1   [ 10 ]   extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001–U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as&amp;#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected.  The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document.   [ edit ]  Encoding detection   The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;. Unicode itself defines encodings that cover the entire repertoire; well-known ones include UTF-8 and UTF-16 .   [ 11 ]   There are many other text encodings that pre-date Unicode, such as ASCII and ISO/IEC 8859 ; their character repertoires in almost every case are subsets of the Unicode character set.  XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.   [ 12 ]   Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser.   [ edit ]  Escaping   XML provides  escape  facilities for including characters which are problematic to include directly. For example:   The characters &quot;&lt;&quot; and &quot;&amp;&quot; are key syntax markers and may never appear in content outside of a CDATA section.   [ 13 ]     Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;é&quot;.  It might not be possible to type the character on the author&apos;s machine.  Some characters have glyphs that cannot be visually distinguished from other characters: examples are  non-breaking-space ( &amp;#xa0; ) &quot; &quot;  compare space ( &amp;#x20; ) &quot; &quot;    Cyrillic Capital Letter A ( &amp;#x410; ) &quot;А&quot;  compare Latin Capital Letter A ( &amp;#x61; ) &quot;A&quot;       There are five predefined entities :    &lt; represents &quot;&lt;&quot;   &gt; represents &quot;&gt;&quot;   &amp; represents &quot;&amp;&quot;   &amp;apos; represents &apos;   &quot; represents &quot;   All permitted Unicode characters may be represented with a  numeric character reference  . Consider the Chinese character &quot;中&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013. A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as &amp;#20013; or &amp;#x4e2d; . Similarly, the string &quot; I&lt;3 Jörg &quot; could be encoded for inclusion in an XML document as &quot; I&lt;3 J&amp;#xF6;rg &quot;.  &quot; &amp;#0; &quot; is not permitted, however, because the null character is one of the control characters excluded from XML, even when using a numeric character reference.   [ 14 ]   An alternative encoding mechanism such as Base64 is needed to represent such characters.   [ edit ]  Comments   Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot; -- &quot; (double-hyphen) is not allowed inside comments. Comments start with &quot;&lt;!--&quot;. The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding.  An example of a valid comment: &quot; &lt;!-- no need to escape&lt;code&gt;&amp;such in comments --&gt; &quot;   [ edit ]  International use         This example contains Chinese text. Without proper rendering support , you may see question marks, boxes, or other symbols instead of Chinese characters .          This example contains Cyrillic text . Without proper rendering support , you may see question marks or boxes , misplaced vowels or missing conjuncts instead of Cyrillic letters.    XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&lt;&quot;). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters:      &lt;?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?&gt;   &lt;俄语 &gt;  данные &lt;/俄语 &gt;       [ edit ]  Well-formedness and error-handling   Main article: Well-formed document   The XML specification defines an XML document as a text that is well-formed , i.e. it satisfies a list of syntax rules provided in the specification. The list is fairly lengthy; some key points are:   It contains only properly encoded legal Unicode characters.  None of the special syntax characters such as &quot;&lt;&quot; and &quot;&amp;&quot; appear except when performing their markup-delineation roles.  The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping.  The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters !&quot;#$%&amp;&apos;()*+,/;&lt;=&gt;?@[\]^`{|}~, nor a space character, and cannot start with -, ., or a numeric digit.  There is a single &quot;root&quot; element that contains all the other elements.   The definition of an XML document excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as draconian , stands in notable contrast to the behavior of programs that process HTML , which are designed to produce a reasonable result even in the presence of severe markup errors.   [ 15 ]   XML&apos;s policy in this area has been criticized as a violation of Postel&apos;s law (&quot;Be conservative in what you send; be liberal in what you accept&quot;).   [ 16 ]      [ edit ]  Schemas and validation   In addition to being well-formed, an XML document may be valid . This means that it contains a reference to a Document Type Definition (DTD) , and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies.  XML processors are classified as validating or non-validating depending on whether or not they check XML documents for validity. A processor that discovers a validity error must be able to report it, but may continue normal processing.  A DTD is an example of a  schema  or grammar . Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships.   [ edit ]  DTD   Main article: Document Type Definition   The oldest schema language for XML is the Document Type Definition (DTD), inherited from SGML .  DTDs have the following benefits:   DTD support is ubiquitous due to its inclusion in the XML 1.0 standard.  DTDs are terse compared to element-based schema languages and consequently present more information in a single screen.  DTDs allow the declaration of standard public entity sets for publishing characters.  DTDs define a document type rather than the types used by a namespace, thus grouping all constraints for a document in a single collection.   DTDs have the following limitations:   They have no explicit support for newer features of XML, most importantly namespaces .  They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes.  They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual macros ), which make it easier to define complex grammars, but at the expense of clarity.  They use a syntax based on regular expression syntax, inherited from SGML , to describe the schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.   Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining entities , which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes.  DTD technology is still used in many applications because of its ubiquity.   [ edit ]  XML Schema   Main article: XML Schema (W3C)   A newer schema language, described by the W3C as the successor of DTDs, is XML Schema , often referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system and allow for more detailed constraints on an XML document&apos;s logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them.   [ edit ]  RELAX NG   Main article: RELAX NG    RELAX NG was initially specified by OASIS and is now also an ISO/IEC International Standard (as part of DSDL ). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are isomorphic and James Clark &apos;s Trang conversion tool can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins ; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.   [ edit ]  Schematron   Main article: Schematron    Schematron is a language for making assertions about the presence or absence of patterns in an XML document. It typically uses XPath expressions.   [ edit ]  ISO DSDL and other schema languages   The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing .  Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the infoset augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these.   [ edit ]  Related specifications   A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0. It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core.    XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces.   XML Base defines the xml:base attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element.  The XML Information Set or XML infoset describes an abstract data model for XML documents in terms of information items . The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow.  xml:id Version 1.0 asserts that an attribute named xml:id functions as an &quot;ID attribute&quot; in the sense used in a DTD.   XPath defines a syntax named XPath expressions which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document. XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data.   XSLT is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes.   XSL Formatting Objects , or XSL-FO, is a markup language for XML document formatting which is most often used to generate PDFs .   XQuery is an XML-oriented query language strongly rooted in XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for XML databases .   XML Signature defines syntax and processing rules for creating digital signatures on XML content.   XML Encryption defines syntax and processing rules for encrypting XML content.   Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including XInclude , XLink , and XPointer .   [ edit ]  Use on the Internet   XML has come into common use for the interchange of data over the Internet. RFC 3023 gives rules for the construction of Internet Media Types for use when sending XML. It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data are in XML, and nothing about its semantics . The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.   [ 3 ]    RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for SVG .  Further guidelines for the use of XML in a networked context may be found in RFC 3470 , also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language.  XML can also form a crucial part of a databaseless design .   [ edit ]  Programming interfaces   The design goals of XML include, &quot;It shall be easy to write programs which process XML documents.&quot;   [ 6 ]   Despite this, the XML specification contains almost no information about how programmers might go about doing such processing. The XML Infoset specification provides a vocabulary to refer to the constructs within an XML document, but also does not provide any guidance on how to access this information. A variety of APIs for accessing XML have been developed and used, and some have been standardized.  Existing APIs for XML processing tend to fall into these categories:   Stream-oriented APIs accessible from a programming language, for example SAX and StAX .  Tree-traversal APIs accessible from a programming language, for example DOM .   XML data binding , which provides an automated translation between an XML document and programming-language objects.  Declarative transformation languages such as XSLT and XQuery .   Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives. Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions.  XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large XML databases .   [ edit ]  Simple API for XML (SAX)    SAX is a lexical , event-driven interface in which a document is read serially and its contents are reported as callbacks to various methods on a handler object of the user&apos;s design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.   [ edit ]  Pull parsing   Pull parsing   [ 17 ]   treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLReader in PHP and System.Xml.XmlReader in the .NET Framework .  A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace , values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code..   [ edit ]  Document Object Model   The Document Object Model (DOM) is an interface -oriented application programming interface that allows for navigation of the entire document as if it were a tree of node  objects representing the document&apos;s contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings . DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.   [ edit ]  Data binding   Another form of XML processing API is XML data binding , where XML data are made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB) and XML Serialization in .NET.   [ 18 ]      [ edit ]  XML as data type   XML is beginning to appear as a first-class data type in other languages. The ECMAScript for XML (E4X) extension to the ECMAScript /JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.   [ 19 ]   E4X is supported by the Mozilla 2.5+ browsers and Adobe Actionscript , but has not been adopted more universally. Similar notations are used in Microsoft&apos;s LINQ implementation for Microsoft .NET 3.5 and above, and in Scala (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the&lt;[ ]&gt;notation.   [ 20 ]   The Resource Description Framework defines a data type rdf:XMLLiteral to hold wrapped, canonical XML .   [ 21 ]      [ edit ]  History   XML is an application profile of SGML (ISO 8879).   [ 22 ]     The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.   [ 23 ]      [ 24 ]   By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web , and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C&apos;s activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.   [ 25 ]     XML was compiled by a working group of eleven members,   [ 26 ]   supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.   [ 27 ]    James Clark served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty /&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen . Halfway through the project Bray accepted a consulting engagement with Netscape , provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft&apos;s Jean Paoli as a third co-editor.  The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in a short burst of intense work between August and November 1996   [ 28 ]   , when the first Working Draft of an XML specification was published.   [ 29 ]   Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998.   [ edit ]  Sources    XML is a profile of an ISO standard SGML , and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ( processing instructions ), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set ).  Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and HTML , in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP ) metadata accompanied the resource rather than being needed at the declaration of a link. The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0&apos;s naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime .  Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;   [ 30 ]   the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System.   [ edit ]  Versions   There are two current versions of XML. The first ( XML 1.0 ) was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use.  The second ( XML 1.1 ) was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,   [ 31 ]   and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.   [ 32 ]   The main changes are to enable the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.   [ 33 ]     Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the Unicode standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces redundancy . The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the Balinese , Cham , or Phoenician scripts among many others which have been added to Unicode since Unicode 3.2.   [ 32 ]     Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references   [ 34 ]   ). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.  There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for skunkworks ), written by one of the original developers of XML,   [ 35 ]   contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces , XML Base and XML Information Set ( infoset ) into the base standard.  The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name  Fast Infoset  for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).   [ edit ]  Criticism   XML and its extensions have regularly been criticized for verbosity and complexity.   [ 36 ]   Mapping the basic tree model of XML to type systems of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a self-describing language   [ 37 ]   (though the XML specification itself makes no such claim). JSON and YAML are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents.   [ edit ]  See also     List of XML markup languages    Comparison of layout engines (XML)    Binary XML    EBML    WBXML    Category:XML    Category:XML-based standards    Billion laughs (a denial-of-service attack on XML parsers)   XML Protocol    Comparison of data serialization formats     [ edit ]  References       ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 9–11 . http://tools.ietf.org/html/rfc3023#section-3.2   . Retrieved 2010-01-04 .          ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 7–9 . http://tools.ietf.org/html/rfc3023#section-3.1   . Retrieved 2010-01-04 .        ^    a        b     M. Murata, D. Kohn, and C. Lilley (2009-09-24). &quot;Internet Drafts: XML Media Types&quot; . IETF . http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03   . Retrieved 2010-06-10 .          ^    &quot;XML 1.0 Specification&quot; . W3.org . http://www.w3.org/TR/REC-xml   . Retrieved 2010-08-22 .          ^    &quot;W3C DOCUMENT LICENSE&quot;  . http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231  .        ^    a        b      &quot;XML 1.0 Origin and Goals&quot;  . http://www.w3.org/TR/REC-xml/#sec-origin-goals   . Retrieved July 2009 .          ^    &quot;XML Applications and Initiatives&quot;  . http://xml.coverpages.org/xmlApplications.html  .          ^    &quot;Introduction to iWork Programming Guide. Mac OS X Reference Library&quot; . Apple . http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html  .          ^    &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot; . W3.org . http://www.w3.org/TR/2006/REC-xml-20060816/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#charsets   . Retrieved 2010-08-22 .          ^    &quot;Characters vs. Bytes&quot;  . http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF  .          ^    &quot;Autodetection of Character Encodings&quot;  . http://www.w3.org/TR/REC-xml/#sec-guessing  .          ^  It is allowed, but not recommended, to use &quot;&lt;&quot; in XML entity values: Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition     ^    &quot;W3C I18N FAQ: HTML, XHTML, XML and Control Codes&quot;  . http://www.w3.org/International/questions/qa-controls  .          ^   http://web.archive.org/web/20110726002036/http://diveintomark.org/archives/2004/01/16/draconianism     ^   http://web.archive.org/web/20110514120305/http://diveintomark.org/archives/2004/01/08/postels-law     ^   Push, Pull, Next! by Bob DuCharme, at XML.com    ^    &quot;XML Serialization in the .NET Framework&quot; . Msdn.microsoft.com . http://msdn.microsoft.com/en-us/library/ms950721.aspx   . Retrieved 2009-07-31 .          ^    &quot;Processing XML with E4X&quot; . Mozilla Developer Center . Mozilla Foundation . https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x  .          ^    &quot;XML Shell: Core Syntax&quot; . xmlsh. 2010-05-13 . http://www.xmlsh.org/CoreSyntax   . Retrieved 2010-08-22 .          ^    &quot;Resource Description Framework (RDF): Concepts and Abstract Syntax&quot; . W3.org . http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral   . Retrieved 2010-08-22 .          ^    ISO/IEC 19757-3 . ISO / IEC . 1 June 2006. p. vi          ^   Bray, Tim (February 2005). &quot;A conversation with Tim Bray: Searching for ways to tame the world&apos;s vast stores of information&quot; . Association for Computing Machinery&apos;s &quot;Queue site&quot; . http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282   . Retrieved April 16, 2006 .          ^   edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley. (1988). &quot;Publishers, multimedia, and interactivity&quot;. Interactive multimedia . Cobb Group. ISBN   1-55615-124-1 .          ^   Eliot Kimber (2006). &quot;XML is 10&quot;  . http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html  .          ^  The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210 .    ^    &quot;Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG&quot; . W3.org . http://www.w3.org/XML/9712-reports.html   . Retrieved 2009-07-31 .          ^  Jon Bosak: The Birth of XML     ^    &quot;Extensible Markup Language (XML)&quot; . W3.org. 1996-11-14 . http://www.w3.org/TR/WD-xml-961114.html   . Retrieved 2009-07-31 .          ^   Jon Bosak, Sun Microsystems (2006-12-07). &quot;Closing Keynote, XML 2006&quot; . 2006.xmlconference.org . http://2006.xmlconference.org/proceedings/162/presentation.html   . Retrieved 2009-07-31 .          ^    &quot;Extensible Markup Language (XML) 1.0 (Third Edition)&quot; . W3.org . http://www.w3.org/TR/2004/REC-xml-20040204   . Retrieved 2010-08-22 .        ^    a        b      &quot;Extensible Markup Language (XML) 1.1 (Second Edition) – Rationale and list of changes for XML 1.1&quot; . W3C . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2012-01-20 .          ^   Harold, Elliotte Rusty (2004).  Effective XML  . Addison-Wesley. pp. 10–19. ISBN   0321150406  . http://www.cafeconleche.org/books/effectivexml/  .          ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2010-08-22 .          ^  Tim Bray:  Extensible Markup Language - SW (XML-SW) . 2002-02-10    ^  Jeff Atwood (2009): XML: The Angle Bracket Tax     ^  Eric Brown (2003): The Myth of Self-Describing XML      [ edit ]  Further reading    Annex A of ISO 8879:1986 (SGML)   Lawrence A. Cunningham (2005). &quot;Language, Deals and Standards: The Future of XML Contracts&quot;. Washington University Law Review . SSRN   900616 .         Bosak, Jon; Tim Bray (May 1999). &quot;XML and the Second-Generation Web&quot;. Scientific American .      Online at XML and the Second-Generation Web .    Kelly, Sean (February 6, 2006). &quot;Making Mistakes with XML&quot; . Developer.com  . http://www.developer.com/xml/article.php/10929_3583081_1   . Retrieved 2010-10-26 .         Ogbuji, Uche (14 Nov 2006). &quot;Thinking XML: The XML decade&quot; . developerWorks . IBM  . http://www-128.ibm.com/developerworks/library/x-think38.html   . Retrieved 2010-10-26 .         St. Laurent, Simon (February 12, 2003). &quot;Five years later, XML..&quot; . O&apos;Reilly XML Blog . O&apos;Reilly Media  . http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html   . Retrieved 2010-10-26 .          &quot;W3C XML is Ten!&quot; . World Wide Web Consortium . 12 February 2008 . http://www.w3.org/2008/02/xml10-pressrelease   . Retrieved 2010-10-26 .         Flynn, Peter [ed] (5 January 2011). &quot;The XML FAQ&quot; . Cork: Silmaril . http://xml.silmaril.ie/  .          [ edit ]  External links        Wikimedia Commons has media related to:   XML            Wikibooks has more on the topic of    XML               This article&apos;s use of external links may not follow Wikipedia&apos;s policies or guidelines . Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references   (November 2010)        W3C XML homepage    XML 1.0 Specification    Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe    XML, Java and the Future of the Web by Jon Bosak    XML.gov    XML: Ten year anniversary by Elliot Kimber   23 XML fallacies to watch out for by Sean McGrath   XML Injection - Web Application Security Consortium                v      d      e       World Wide Web Consortium          Products and standards         Recommendations        Canonical XML    CDF    CSS    DOM    Geolocation API    HTML    ITS    MathML    OWL    P3P    PLS    RDF    RDF Schema    SISR    SKOS    SMIL    SOAP    SRGS    SSML    SVG    SPARQL    Timed Text    VoiceXML    WSDL    XForms    XHTML    XHTML+RDFa    XInclude    XLink    XML    XML Base    XML Encryption    XML Events    XML Information Set    XML namespace    XML Schema    XML Signature    XPath  1.0 , 2.0    XPointer    XProc    XQuery    XSL    XSL-FO    XSLT  ( elements )             Notes       XAdES    XHTML+SMIL    XUP             Working Drafts       CCXML    CURIE    HTML5    InkML    RIF    SCXML    SMIL Timesheets    sXBL    WICD    XFDL    XFrames    XBL    XHTML+MathML+SVG    XMLHttpRequest             Guidelines       Web Content Accessibility Guidelines             Initiative       Multimodal Interaction Activity    Markup Validation Service    Web Accessibility Initiative             Deprecated       C-HTML    HDML    JSSS    PGML    VML               Organizations      World Wide Web Foundation    SVG Working Group    WebOnt    W3C Device Description Working Group    WHATWG            Software      Agora    Argo    Arena    Amaya    CERN httpd    Libwww    Line Mode Browser            Conference-related      IW3C2    World Wide Web Conference    WWW1            Retrieved from &quot; http://en.wikipedia.org/w/index.php?title=XML&amp;oldid=472314787 &quot;    Categories :   XML    Markup languages    World Wide Web Consortium standards    Technical communication    Bibliography file formats    Computer file formats    Open formats    Data modeling languages    Data serialization formats    Application layer protocols    Presentation layer protocols     Hidden categories:   Articles containing potentially dated statements from 2009    All articles containing potentially dated statements    Wikipedia external links cleanup from November 2010    Wikipedia spam cleanup from November 2010            Personal tools    Log in / create account       Namespaces     Article      Talk        Variants             Views     Read      Edit      View history        Actions            Search                     Navigation     Main page    Contents    Featured content    Current events    Random article    Donate to Wikipedia       Interaction     Help    About Wikipedia    Community portal    Recent changes    Contact Wikipedia       Toolbox     What links here    Related changes    Upload file    Special pages    Permanent link    Cite this page       Print/export     Create a book    Download as PDF    Printable version       Languages     Afrikaans    العربية    Azərbaycanca    বাংলা    Bosanski    Български    Català    Česky    Dansk    Deutsch    Eesti    Ελληνικά    Español    Esperanto    Euskara    فارسی    Français    Gaeilge    Galego    한국어    हिन्दी    Hrvatski    Bahasa Indonesia    Interlingua    Íslenska    Italiano    עברית    ລາວ    Latviešu    Lietuvių    Magyar    Македонски    മലയാളം    Bahasa Melayu    Монгол    Nederlands    日本語    ‪Norsk (bokmål)‬    ‪Norsk (nynorsk)‬    Polski    Português    Română    Русский    Shqip    Simple English    Slovenčina    Slovenščina    کوردی    Српски / Srpski    Srpskohrvatski / Српскохрватски    Suomi    Svenska    தமிழ்    తెలుగు    ไทย    Тоҷикӣ    Türkçe    Türkmençe    Українська    اردو    Tiếng Việt    Žemaitėška    中文         This page was last modified on 20 January 2012 at 20:09.   Text is available under the Creative Commons Attribution-ShareAlike License   ;
additional terms may apply.
See Terms of use for details. Wikipedia®is a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization.    Contact us      Privacy policy    About Wikipedia    Disclaimers    Mobile view                          
  </body>


  <title> How Much Food Do I Feed My Dog — Dr. Gregs Dog Dish Diet</title>
  <body>
      Home    Order Dog Dish Diet Now!    Testimonials    Who is Dr. Greg?    Contact Dr. Greg    PDF Introduction to Crock Pot Cooking Access With Purchase    Dog Dish Diet Videos              How Much Dry Food Should I Feed My Dog?  by Dr Greg on July 24, 2011           In my book, Dog Dish Diet, I go over the calories in dry and canned food and the amount of daily calories a dog should be fed. However, most people use a scoop or their hand to measure dry food. If your dog looks good…no need to change your methods. If your dog is on the chunky side, overweight, or grossly fat you need to measure out the food you feed them. You may also want to consider diluting  the calories in dry food with water or green beans, or feeding something with less carbohydrate calories like canned food,  home cooked food, or a piece of chicken 2-3 nights per week instead of dry food or kibble. Dog Dish Diet teaches us to feed better by learning about ingredients. Some dogs are suffering and dying because they can’t tolerate the ingredients in some commercial foods.( chronic skin problems, ear problems , bladder infections and stones , seizures, diarrhea, diabetes, fatty tumors to name a few)   If your dog has skin, ear, bowel, bladder, or seizure problems consider the Dog Dish Diet and feed your pet to avoid the vet!    Here is a question I received on facebook today:    Doc.. about how much of the chicken stew would a 50lb dog and 80lb dog need daily if the diet was to be changed from dry to this.. of course it would be a gradual change not to upset tummies    My Answer:          My 80 lb lab eats about 12 oz twice daily. My 10 lb terrier mix eats 6 oz twice daily. My 10 pound bichon/poodle cross eats 6 oz twice daily. You can see that my small dogs need to eat more ounces per pound. In general, dogs need 10-50 calories per pound per day depending on their individual metabolism and energy level.(how much fuel they burn during their normal daily activities)Your  50 pound dog needs anywhere from 500-2500 calories per day depending on activity level. I usually assume 10-20 cal/pound/day for medium to large breeds, 20-30 cal/ pound /day for medium dogs, and 30-40 cal/pound /day for small active dogs. So the stew is 35 calories per ounce, and if 1000 calories needed, about 30 ounces (15 ounces twice daily). The bigger dogs often need less per pound than medium and small dogs unless they move a lot. The 80 pound would get the same or 25 ounces once daily (12 ounces twice daily). Many clients add the stew to moistened dry food as a supplement. One cup 2-3 times a week.      Dry food is usually 45 calories per ounce, canned food is roughly 25 calories per ounce. An 80 pound overweight dog may only need 800 calories per day because they are a slug. This would be about 18 ounces of dry food(2 cups)(or and no hi carb treats!!      Some dogs can’t handle the carbs in dry food or kibble. They gain weight no matter how little dry food they are given. They develop lipomas or fatty tumors. They have dry, flaky, skin. They need more protein, fats, and oils in their diet. Don’t keep feeding the same type of dry, high carbohydrate, low fat food and expect different results. Feed your pet to avoid the vet!!                Leave a Comment      Name *      E-mail *      Website                   Previous post: Temporary Home Remedies for Ear Infections   Next post: Why Does My Dog Eat Poop?                Find more at MindBites, the how-to video marketplace !      Always be among the first to know      Want more articles like the ones to the left?
For your convenience, I’ll send my latest posts directly to your inbox. Sign up now…it’s simple.                    Name:       Email:                             Order your special autographed copy now!           Archives    January 2012    December 2011    November 2011    October 2011    September 2011    August 2011    July 2011    June 2011    May 2011    April 2011    March 2011    February 2011    January 2011    December 2010    November 2010    October 2010    September 2010    August 2010    July 2010    June 2010    May 2010    April 2010    March 2010    February 2010    January 2010    December 2009    November 2009    October 2009    September 2009    August 2009    July 2009    June 2009             Receive your  FREE Copy of Dr. Greg&apos;s 11 Practical Home Remedies for Your Dog              Name       Email                    Dog Dish Diet Wins Gold Medal, 2010 Living Now Book Award         Dog Dish Diet Honored with a 2010 Indie Excellence Award         Dog Dish Diet Receives 2010 Next Generation Book Award, Finalist         Dog Dish Diet Wins 2010 San Francisco Book Festival, Honorable Mention                         Tags   California  california veterinarian  canine flu  canine health  canine nutrition  canine vaccines  canine viruses  cat food  cat health  cats  changing do habits  dog bones  Dog Dish Diet  dog food  dog food allergies  dog health  dog nutrition  dog tumors  Dr. Greg  Dr. Greg&apos;s Dog Dish Diet  ear problems in dogs  funny animal story  Gilroy  Gilroy Today  glucosamine  Greg Martinez DVM  healthy dog food  healthy dog snack  healthy eating for cats  healthy eating for dogs  joint pain  neutraceuticals  Omega 3  OPC  overweight cats  parrot  parvo  people food for dogs  pets  pet safety  poisons  radio broadcast  tick-borne diseases  ticks  veterinarian           Dog Dish Diet on Facebook          © 2011 Greg Martinez, DVM   WordPress Admin         
  </body>


  <title> XML - Wikipedia, the free encyclopedia</title>
  <body>
            XML   From Wikipedia, the free encyclopedia    Jump to: navigation , search        XML           Filename extension    .xml      Internet media type    application/xml ,   [ 1 ]     text/xml    [ 2 ]   (deprecated in an expired draft)   [ 3 ]        Uniform Type Identifier   public.xml    UTI conforms to  public.text    Developed by   World Wide Web Consortium     Type of format   Markup language     Extended from   SGML     Extended to   Numerous , including:  XHTML , RSS , Atom , KML      Standard(s)    1.0 (Fifth Edition) November 26, 2008 ; 3 years ago  ( 2008-11-26 )   1.1 (Second Edition) August 16, 2006 ; 5 years ago  ( 2006-08-16 )      Open format ?  Yes      Extensible Markup Language (XML)    Current Status  Published    Year Started  1996    Editors  Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan    Related Standards   XML Schema     Domain   Data Serialization     Abbreviation  XML    Website   XML 1.0         Extensible Markup Language ( XML ) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable . It is defined in the XML 1.0 Specification   [ 4 ]   produced by the W3C , and several other related specifications, all gratis  open standards .   [ 5 ]     The design goals of XML emphasize simplicity, generality, and usability over the Internet .   [ 6 ]   It is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary data structures , for example in web services .  Many application programming interfaces (APIs) have been developed for software developers to use to process XML data, and several schema systems exist to aid in the definition of XML-based languages.  As of 2009  [update]  , hundreds of XML-based languages have been developed,   [ 7 ]   including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for many office-productivity tools, including Microsoft Office ( Office Open XML ), OpenOffice.org ( OpenDocument ), and Apple &apos;s iWork .   [ 8 ]   XML has also been employed as the base language for communication protocols , such as XMPP .      Contents      1  Key terminology      2  Characters and escaping      2.1  Valid characters      2.2  Encoding detection      2.3  Escaping      2.4  Comments      2.5  International use        3  Well-formedness and error-handling      4  Schemas and validation      4.1  DTD      4.2  XML Schema      4.3  RELAX NG      4.4  Schematron      4.5  ISO DSDL and other schema languages        5  Related specifications      6  Use on the Internet      7  Programming interfaces      7.1  Simple API for XML (SAX)      7.2  Pull parsing      7.3  Document Object Model      7.4  Data binding      7.5  XML as data type        8  History      8.1  Sources      8.2  Versions        9  Criticism      10  See also      11  References      12  Further reading      13  External links         [ edit ]  Key terminology   The material in this section is based on the XML Specification. This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use.   (Unicode) Character  By definition, an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document.    Processor and Application  The processor analyzes the markup and passes structured information to an application . The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an XML parser .    Markup and Content  The characters which make up an XML document are divided into markup and content . Markup and content may be distinguished by the application of simple syntactic rules. All strings which constitute markup either begin with the character &quot;&quot; and end with a &quot;&quot;, or begin with the character &quot;&quot; and end with a &quot;;&quot;. Strings of characters which are not markup are content.    Tag  A markup construct that begins with &quot;&quot; and ends with &quot;&quot;. Tags come in three flavors: start-tags , for example section , end-tags , for example /section , and empty-element tags , for example line-break/ .    Element  A logical document component either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start- and end-tags, if any, are the element&apos;s content , and may contain markup, including other elements, which are called child elements . An example of an element is GreetingHello,world./Greeting (see hello world ). Another is line-break/ .    Attribute  A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag. In the example (below) the element img has two attributes, src and alt : imgsrc=&quot;madonna.jpg&quot;alt=&apos;FolignoMadonna,byRaphael&apos;/ . Another example would be stepnumber=&quot;3&quot;ConnectAtoB./step where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;.    XML Declaration  XML documents may begin by declaring some information about themselves, as in the following example.       ?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?       [ edit ]  Characters and escaping   XML documents consist entirely of characters from the Unicode repertoire. Except for a small number of specifically excluded control characters , any character defined by Unicode may appear within the content of an XML document. The selection of characters that may appear within markup is somewhat more limited but still large.  XML includes facilities for identifying the encoding of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly.   [ edit ]  Valid characters   Main article: Valid characters in XML   Unicode code points in the following ranges are valid in XML 1.0 documents:   [ 9 ]      U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0;  U+0020–U+D7FF, U+E000–U+FFFD: this excludes some (not all) non-characters in the BMP (all surrogates, U+FFFE and U+FFFF are forbidden);  U+10000–U+10FFFF: this includes all code points in supplementary planes, including non-characters.   XML 1.1   [ 10 ]   extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001–U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected.  The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document.   [ edit ]  Encoding detection   The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;. Unicode itself defines encodings that cover the entire repertoire; well-known ones include UTF-8 and UTF-16 .   [ 11 ]   There are many other text encodings that pre-date Unicode, such as ASCII and ISO/IEC 8859 ; their character repertoires in almost every case are subsets of the Unicode character set.  XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.   [ 12 ]   Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser.   [ edit ]  Escaping   XML provides  escape  facilities for including characters which are problematic to include directly. For example:   The characters &quot;&quot; and &quot;&quot; are key syntax markers and may never appear in content outside of a CDATA section.   [ 13 ]     Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;é&quot;.  It might not be possible to type the character on the author&apos;s machine.  Some characters have glyphs that cannot be visually distinguished from other characters: examples are  non-breaking-space ( #xa0; ) &quot;&quot;  compare space ( #x20; ) &quot; &quot;    Cyrillic Capital Letter A ( #x410; ) &quot;А&quot;  compare Latin Capital Letter A ( #x61; ) &quot;A&quot;       There are five predefined entities :    lt; represents &quot;&quot;   gt; represents &quot;&quot;   amp; represents &quot;&quot;   apos; represents &apos;   quot; represents &quot;   All permitted Unicode characters may be represented with a  numeric character reference  . Consider the Chinese character &quot;中&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013. A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as #20013; or #x4e2d; . Similarly, the string &quot; I3 Jörg &quot; could be encoded for inclusion in an XML document as &quot; Ilt;3 J#xF6;rg &quot;.  &quot; #0; &quot; is not permitted, however, because the null character is one of the control characters excluded from XML, even when using a numeric character reference.   [ 14 ]   An alternative encoding mechanism such as Base64 is needed to represent such characters.   [ edit ]  Comments   Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot; -- &quot; (double-hyphen) is not allowed inside comments. Comments start with &quot;!--&quot;. The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding.  An example of a valid comment: &quot; !-- no need to escapecodesuch in comments -- &quot;   [ edit ]  International use         This example contains Chinese text. Without proper rendering support , you may see question marks, boxes, or other symbols instead of Chinese characters .          This example contains Cyrillic text . Without proper rendering support , you may see question marks or boxes , misplaced vowels or missing conjuncts instead of Cyrillic letters.    XML supports the direct use of almost any Unicode character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&quot;). Therefore, the following is a well-formed XML document, even though it includes both Chinese and Cyrillic characters:      ?xml  version = &quot;1.0&quot;  encoding = &quot;UTF-8&quot;  ?   俄语   данные /俄语        [ edit ]  Well-formedness and error-handling   Main article: Well-formed document   The XML specification defines an XML document as a text that is well-formed , i.e. it satisfies a list of syntax rules provided in the specification. The list is fairly lengthy; some key points are:   It contains only properly encoded legal Unicode characters.  None of the special syntax characters such as &quot;&quot; and &quot;&quot; appear except when performing their markup-delineation roles.  The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping.  The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters !&quot;#$%&apos;()*+,/;=?@[\]^`{|}~, nor a space character, and cannot start with -, ., or a numeric digit.  There is a single &quot;root&quot; element that contains all the other elements.   The definition of an XML document excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as draconian , stands in notable contrast to the behavior of programs that process HTML , which are designed to produce a reasonable result even in the presence of severe markup errors.   [ 15 ]   XML&apos;s policy in this area has been criticized as a violation of Postel&apos;s law (&quot;Be conservative in what you send; be liberal in what you accept&quot;).   [ 16 ]      [ edit ]  Schemas and validation   In addition to being well-formed, an XML document may be valid . This means that it contains a reference to a Document Type Definition (DTD) , and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies.  XML processors are classified as validating or non-validating depending on whether or not they check XML documents for validity. A processor that discovers a validity error must be able to report it, but may continue normal processing.  A DTD is an example of a  schema  or grammar . Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships.   [ edit ]  DTD   Main article: Document Type Definition   The oldest schema language for XML is the Document Type Definition (DTD), inherited from SGML .  DTDs have the following benefits:   DTD support is ubiquitous due to its inclusion in the XML 1.0 standard.  DTDs are terse compared to element-based schema languages and consequently present more information in a single screen.  DTDs allow the declaration of standard public entity sets for publishing characters.  DTDs define a document type rather than the types used by a namespace, thus grouping all constraints for a document in a single collection.   DTDs have the following limitations:   They have no explicit support for newer features of XML, most importantly namespaces .  They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes.  They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual macros ), which make it easier to define complex grammars, but at the expense of clarity.  They use a syntax based on regular expression syntax, inherited from SGML , to describe the schema. Typical XML APIs such as SAX do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.   Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining entities , which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes.  DTD technology is still used in many applications because of its ubiquity.   [ edit ]  XML Schema   Main article: XML Schema (W3C)   A newer schema language, described by the W3C as the successor of DTDs, is XML Schema , often referred to by the initialism for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich datatyping system and allow for more detailed constraints on an XML document&apos;s logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them.   [ edit ]  RELAX NG   Main article: RELAX NG    RELAX NG was initially specified by OASIS and is now also an ISO/IEC International Standard (as part of DSDL ). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are isomorphic and James Clark &apos;s Trang conversion tool can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use datatype framework plug-ins ; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.   [ edit ]  Schematron   Main article: Schematron    Schematron is a language for making assertions about the presence or absence of patterns in an XML document. It typically uses XPath expressions.   [ edit ]  ISO DSDL and other schema languages   The ISO DSDL (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes RELAX NG full and compact syntax, Schematron assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based routing of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for publishing .  Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the infoset augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these.   [ edit ]  Related specifications   A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0. It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core.    XML Namespaces enable the same document to contain XML elements and attributes taken from different vocabularies, without any naming collisions occurring. Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces.   XML Base defines the xml:base attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element.  The XML Information Set or XML infoset describes an abstract data model for XML documents in terms of information items . The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow.  xml:id Version 1.0 asserts that an attribute named xml:id functions as an &quot;ID attribute&quot; in the sense used in a DTD.   XPath defines a syntax named XPath expressions which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document. XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data.   XSLT is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes.   XSL Formatting Objects , or XSL-FO, is a markup language for XML document formatting which is most often used to generate PDFs .   XQuery is an XML-oriented query language strongly rooted in XPath and XML Schema. It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for XML databases .   XML Signature defines syntax and processing rules for creating digital signatures on XML content.   XML Encryption defines syntax and processing rules for encrypting XML content.   Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including XInclude , XLink , and XPointer .   [ edit ]  Use on the Internet   XML has come into common use for the interchange of data over the Internet. RFC 3023 gives rules for the construction of Internet Media Types for use when sending XML. It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data are in XML, and nothing about its semantics . The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.   [ 3 ]    RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for SVG .  Further guidelines for the use of XML in a networked context may be found in RFC 3470 , also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language.  XML can also form a crucial part of a databaseless design .   [ edit ]  Programming interfaces   The design goals of XML include, &quot;It shall be easy to write programs which process XML documents.&quot;   [ 6 ]   Despite this, the XML specification contains almost no information about how programmers might go about doing such processing. The XML Infoset specification provides a vocabulary to refer to the constructs within an XML document, but also does not provide any guidance on how to access this information. A variety of APIs for accessing XML have been developed and used, and some have been standardized.  Existing APIs for XML processing tend to fall into these categories:   Stream-oriented APIs accessible from a programming language, for example SAX and StAX .  Tree-traversal APIs accessible from a programming language, for example DOM .   XML data binding , which provides an automated translation between an XML document and programming-language objects.  Declarative transformation languages such as XSLT and XQuery .   Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives. Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions.  XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large XML databases .   [ edit ]  Simple API for XML (SAX)    SAX is a lexical , event-driven interface in which a document is read serially and its contents are reported as callbacks to various methods on a handler object of the user&apos;s design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.   [ edit ]  Pull parsing   Pull parsing   [ 17 ]   treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of recursive-descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLReader in PHP and System.Xml.XmlReader in the .NET Framework .  A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace , values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code..   [ edit ]  Document Object Model   The Document Object Model (DOM) is an interface -oriented application programming interface that allows for navigation of the entire document as if it were a tree of node  objects representing the document&apos;s contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings . DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.   [ edit ]  Data binding   Another form of XML processing API is XML data binding , where XML data are made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a Document Object Model parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB) and XML Serialization in .NET.   [ 18 ]      [ edit ]  XML as data type   XML is beginning to appear as a first-class data type in other languages. The ECMAScript for XML (E4X) extension to the ECMAScript /JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.   [ 19 ]   E4X is supported by the Mozilla 2.5+ browsers and Adobe Actionscript , but has not been adopted more universally. Similar notations are used in Microsoft&apos;s LINQ implementation for Microsoft .NET 3.5 and above, and in Scala (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the[ ]notation.   [ 20 ]   The Resource Description Framework defines a data type rdf:XMLLiteral to hold wrapped, canonical XML .   [ 21 ]      [ edit ]  History   XML is an application profile of SGML (ISO 8879).   [ 22 ]     The versatility of SGML for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.   [ 23 ]      [ 24 ]   By the mid-1990s some practitioners of SGML had gained experience with the then-new World Wide Web , and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew. Dan Connolly added SGML to the list of W3C&apos;s activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer Jon Bosak developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.   [ 25 ]     XML was compiled by a working group of eleven members,   [ 26 ]   supported by an (approximately) 150-member Interest Group. Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by Michael Sperberg-McQueen on December 4, 1997.   [ 27 ]    James Clark served as Technical Lead of the Working Group, notably contributing the empty-element &quot;empty/&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally Tim Bray and Michael Sperberg-McQueen . Halfway through the project Bray accepted a consulting engagement with Netscape , provoking vociferous protests from Microsoft. Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft&apos;s Jean Paoli as a third co-editor.  The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences. The major design decisions were reached in a short burst of intense work between August and November 1996   [ 28 ]   , when the first Working Draft of an XML specification was published.   [ 29 ]   Further design work continued through 1997, and XML 1.0 became a W3C Recommendation on February 10, 1998.   [ edit ]  Sources    XML is a profile of an ISO standard SGML , and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ( processing instructions ), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts Unicode as the document character set ).  Other sources of technology for XML were the Text Encoding Initiative (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and HTML , in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like HTTP ) metadata accompanied the resource rather than being needed at the declaration of a link. The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0&apos;s naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO HyTime .  Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;   [ 30 ]   the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System.   [ edit ]  Versions   There are two current versions of XML. The first ( XML 1.0 ) was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use.  The second ( XML 1.1 ) was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,   [ 31 ]   and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.   [ 32 ]   The main changes are to enable the use of line-ending characters used on EBCDIC platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.   [ 33 ]     Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the Unicode standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces redundancy . The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the Balinese , Cham , or Phoenician scripts among many others which have been added to Unicode since Unicode 3.2.   [ 32 ]     Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more control characters than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references   [ 34 ]   ). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.  There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for skunkworks ), written by one of the original developers of XML,   [ 35 ]   contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of namespaces , XML Base and XML Information Set ( infoset ) into the base standard.  The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name  Fast Infoset  for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).   [ edit ]  Criticism   XML and its extensions have regularly been criticized for verbosity and complexity.   [ 36 ]   Mapping the basic tree model of XML to type systems of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a self-describing language   [ 37 ]   (though the XML specification itself makes no such claim). JSON and YAML are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents.   [ edit ]  See also     List of XML markup languages    Comparison of layout engines (XML)    Binary XML    EBML    WBXML    Category:XML    Category:XML-based standards    Billion laughs (a denial-of-service attack on XML parsers)   XML Protocol    Comparison of data serialization formats     [ edit ]  References       ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 9–11 . http://tools.ietf.org/html/rfc3023#section-3.2   . Retrieved 2010-01-04 .         ^    &quot;XML Media Types, RFC 3023&quot; . IETF. 2001-01. pp. 7–9 . http://tools.ietf.org/html/rfc3023#section-3.1   . Retrieved 2010-01-04 .       ^    a        b     M. Murata, D. Kohn, and C. Lilley (2009-09-24). &quot;Internet Drafts: XML Media Types&quot; . IETF . http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03   . Retrieved 2010-06-10 .         ^    &quot;XML 1.0 Specification&quot; . W3.org . http://www.w3.org/TR/REC-xml   . Retrieved 2010-08-22 .         ^    &quot;W3C DOCUMENT LICENSE&quot;  . http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231  .       ^    a        b      &quot;XML 1.0 Origin and Goals&quot;  . http://www.w3.org/TR/REC-xml/#sec-origin-goals   . Retrieved July 2009 .         ^    &quot;XML Applications and Initiatives&quot;  . http://xml.coverpages.org/xmlApplications.html  .         ^    &quot;Introduction to iWork Programming Guide. Mac OS X Reference Library&quot; . Apple . http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html  .         ^    &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot; . W3.org . http://www.w3.org/TR/2006/REC-xml-20060816/#charsets   . Retrieved 2010-08-22 .         ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#charsets   . Retrieved 2010-08-22 .         ^    &quot;Characters vs. Bytes&quot;  . http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF  .         ^    &quot;Autodetection of Character Encodings&quot;  . http://www.w3.org/TR/REC-xml/#sec-guessing  .         ^  It is allowed, but not recommended, to use &quot;&quot; in XML entity values: Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition     ^    &quot;W3C I18N FAQ: HTML, XHTML, XML and Control Codes&quot;  . http://www.w3.org/International/questions/qa-controls  .         ^   http://web.archive.org/web/20110726002036/http://diveintomark.org/archives/2004/01/16/draconianism     ^   http://web.archive.org/web/20110514120305/http://diveintomark.org/archives/2004/01/08/postels-law     ^   Push, Pull, Next! by Bob DuCharme, at XML.com    ^    &quot;XML Serialization in the .NET Framework&quot; . Msdn.microsoft.com . http://msdn.microsoft.com/en-us/library/ms950721.aspx   . Retrieved 2009-07-31 .         ^    &quot;Processing XML with E4X&quot; . Mozilla Developer Center . Mozilla Foundation . https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x  .         ^    &quot;XML Shell: Core Syntax&quot; . xmlsh. 2010-05-13 . http://www.xmlsh.org/CoreSyntax   . Retrieved 2010-08-22 .         ^    &quot;Resource Description Framework (RDF): Concepts and Abstract Syntax&quot; . W3.org . http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral   . Retrieved 2010-08-22 .         ^    ISO/IEC 19757-3 . ISO / IEC . 1 June 2006. p. vi         ^   Bray, Tim (February 2005). &quot;A conversation with Tim Bray: Searching for ways to tame the world&apos;s vast stores of information&quot; . Association for Computing Machinery&apos;s &quot;Queue site&quot; . http://www.acmqueue.com/modules.php?name=Contentpa=showpagepid=282   . Retrieved April 16, 2006 .         ^   edited by Sueann Ambron and Kristina Hooper; foreword by John Sculley. (1988). &quot;Publishers, multimedia, and interactivity&quot;. Interactive multimedia . Cobb Group. ISBN  1-55615-124-1 .         ^   Eliot Kimber (2006). &quot;XML is 10&quot;  . http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html  .         ^  The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210 .    ^    &quot;Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG&quot; . W3.org . http://www.w3.org/XML/9712-reports.html   . Retrieved 2009-07-31 .         ^  Jon Bosak: The Birth of XML     ^    &quot;Extensible Markup Language (XML)&quot; . W3.org. 1996-11-14 . http://www.w3.org/TR/WD-xml-961114.html   . Retrieved 2009-07-31 .         ^   Jon Bosak, Sun Microsystems (2006-12-07). &quot;Closing Keynote, XML 2006&quot; . 2006.xmlconference.org . http://2006.xmlconference.org/proceedings/162/presentation.html   . Retrieved 2009-07-31 .         ^    &quot;Extensible Markup Language (XML) 1.0 (Third Edition)&quot; . W3.org . http://www.w3.org/TR/2004/REC-xml-20040204   . Retrieved 2010-08-22 .       ^    a        b      &quot;Extensible Markup Language (XML) 1.1 (Second Edition)– Rationale and list of changes for XML 1.1&quot; . W3C . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2012-01-20 .         ^   Harold, Elliotte Rusty (2004).  Effective XML  . Addison-Wesley. pp.10–19. ISBN  0321150406  . http://www.cafeconleche.org/books/effectivexml/  .         ^    &quot;Extensible Markup Language (XML) 1.1 (Second Edition)&quot; . W3.org . http://www.w3.org/TR/xml11/#sec-xml11   . Retrieved 2010-08-22 .         ^  Tim Bray:  Extensible Markup Language - SW (XML-SW) . 2002-02-10    ^  Jeff Atwood (2009): XML: The Angle Bracket Tax     ^  Eric Brown (2003): The Myth of Self-Describing XML      [ edit ]  Further reading    Annex A of ISO 8879:1986 (SGML)   Lawrence A. Cunningham (2005). &quot;Language, Deals and Standards: The Future of XML Contracts&quot;. Washington University Law Review . SSRN  900616 .        Bosak, Jon; Tim Bray (May 1999). &quot;XML and the Second-Generation Web&quot;. Scientific American .     Online at XML and the Second-Generation Web .    Kelly, Sean (February 6, 2006). &quot;Making Mistakes with XML&quot; . Developer.com  . http://www.developer.com/xml/article.php/10929_3583081_1   . Retrieved 2010-10-26 .        Ogbuji, Uche (14 Nov 2006). &quot;Thinking XML: The XML decade&quot; . developerWorks . IBM  . http://www-128.ibm.com/developerworks/library/x-think38.html   . Retrieved 2010-10-26 .        St. Laurent, Simon (February 12, 2003). &quot;Five years later, XML..&quot; . O&apos;Reilly XML Blog . O&apos;Reilly Media  . http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html   . Retrieved 2010-10-26 .         &quot;W3C XML is Ten!&quot; . World Wide Web Consortium . 12 February 2008 . http://www.w3.org/2008/02/xml10-pressrelease   . Retrieved 2010-10-26 .        Flynn, Peter [ed] (5 January 2011). &quot;The XML FAQ&quot; . Cork: Silmaril . http://xml.silmaril.ie/  .         [ edit ]  External links        Wikimedia Commons has media related to:   XML            Wikibooks has more on the topic of    XML               This article&apos;s use of external links may not follow Wikipedia&apos;s policies or guidelines . Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references   (November 2010)        W3C XML homepage    XML 1.0 Specification    Retrospective on Extended Reference Concrete Syntax by Rick Jelliffe    XML, Java and the Future of the Web by Jon Bosak    XML.gov    XML: Ten year anniversary by Elliot Kimber   23 XML fallacies to watch out for by Sean McGrath   XML Injection - Web Application Security Consortium                v      d      e       World Wide Web Consortium          Products and standards         Recommendations        Canonical XML    CDF    CSS    DOM    Geolocation API    HTML    ITS    MathML    OWL    P3P    PLS    RDF    RDF Schema    SISR    SKOS    SMIL    SOAP    SRGS    SSML    SVG    SPARQL    Timed Text    VoiceXML    WSDL    XForms    XHTML    XHTML+RDFa    XInclude    XLink    XML    XML Base    XML Encryption    XML Events    XML Information Set    XML namespace    XML Schema    XML Signature    XPath  1.0 , 2.0    XPointer    XProc    XQuery    XSL    XSL-FO    XSLT  ( elements )             Notes       XAdES    XHTML+SMIL    XUP             Working Drafts       CCXML    CURIE    HTML5    InkML    RIF    SCXML    SMIL Timesheets    sXBL    WICD    XFDL    XFrames    XBL    XHTML+MathML+SVG    XMLHttpRequest             Guidelines       Web Content Accessibility Guidelines             Initiative       Multimodal Interaction Activity    Markup Validation Service    Web Accessibility Initiative             Deprecated       C-HTML    HDML    JSSS    PGML    VML               Organizations      World Wide Web Foundation    SVG Working Group    WebOnt    W3C Device Description Working Group    WHATWG            Software      Agora    Argo    Arena    Amaya    CERN httpd    Libwww    Line Mode Browser            Conference-related      IW3C2    World Wide Web Conference    WWW1            Retrieved from &quot; http://en.wikipedia.org/w/index.php?title=XMLoldid=472314787 &quot;    Categories :   XML    Markup languages    World Wide Web Consortium standards    Technical communication    Bibliography file formats    Computer file formats    Open formats    Data modeling languages    Data serialization formats    Application layer protocols    Presentation layer protocols     Hidden categories:   Articles containing potentially dated statements from 2009    All articles containing potentially dated statements    Wikipedia external links cleanup from November 2010    Wikipedia spam cleanup from November 2010            Personal tools    Log in / create account       Namespaces     Article      Talk        Variants             Views     Read      Edit      View history        Actions            Search                     Navigation     Main page    Contents    Featured content    Current events    Random article    Donate to Wikipedia       Interaction     Help    About Wikipedia    Community portal    Recent changes    Contact Wikipedia       Toolbox     What links here    Related changes    Upload file    Special pages    Permanent link    Cite this page       Print/export     Create a book    Download as PDF    Printable version       Languages     Afrikaans    العربية    Azərbaycanca    বাংলা    Bosanski    Български    Català    Česky    Dansk    Deutsch    Eesti    Ελληνικά    Español    Esperanto    Euskara    فارسی    Français    Gaeilge    Galego    한국어    हिन्दी    Hrvatski    Bahasa Indonesia    Interlingua    Íslenska    Italiano    עברית    ລາວ    Latviešu    Lietuvių    Magyar    Македонски    മലയാളം    Bahasa Melayu    Монгол    Nederlands    日本語    ‪Norsk (bokmål)‬    ‪Norsk (nynorsk)‬    Polski    Português    Română    Русский    Shqip    Simple English    Slovenčina    Slovenščina    کوردی    Српски / Srpski    Srpskohrvatski / Српскохрватски    Suomi    Svenska    தமிழ்    తెలుగు    ไทย    Тоҷикӣ    Türkçe    Türkmençe    Українська    اردو    Tiếng Việt    Žemaitėška    中文         This page was last modified on 20 January 2012 at 20:09.   Text is available under the Creative Commons Attribution-ShareAlike License   ;
additional terms may apply.
See Terms of use for details. Wikipediais a registered trademark of the Wikimedia Foundation, Inc. , a non-profit organization.    Contact us      Privacy policy    About Wikipedia    Disclaimers    Mobile view                          
  </body>
